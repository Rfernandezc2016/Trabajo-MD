---
title: "Memoria del trabajo"
author: "Adrián Rocha De la Casa, Yassin Khalifa Martino y Rocío Fernández Cebrián"
date: "5/10/2021"
output: bookdown::gitbook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#  Introducción

Este conjunto de datos incluye descripciones de muestras hipotéticas basándose en carracterísticas de hongos de la familia Agaricus y Lepiota.

Para visualizar mejor nuestro análisis necesitamos cargar las siguientes librerías:
```{r librerias,echo=TRUE,warning=FALSE}
library(ggplot2)
library(psych)
library(philentropy)
library(kmed)
library(vegan)
library(class)
```

# ¿ Objetivos (del negocio)?

Nuestro objetivo será identifcar cada especie como una especie comestible o una especie venenosa/de comestibilidad desconocida.

#  Datos 

Leemos los datos mediante el siguiente comando:
```{r introduccion datos,echo=TRUE}
datos.setas<-read.table("agaricus-lepiota.data",header=FALSE,sep=",")
```

Comprobamos que se han leído correctamente los datos mirando la dimensión de los datos.
```{r dimension,echo=TRUE}
dim(datos.setas)
```

Como ya hemos visto, disponemos de 8124 observaciones de setas de las cuales hemos recogido información sobre 23 características.

Realizamos una exploración básica de los datos para comprobar que tipo de datos disponemos.
```{r tipo de variables, echo=TRUE}
summary(datos.setas)
```
Luego son variables cualitativas y por tanto habrá que tratarlas como factores. Estas variables son:


 NOMBRE VARIABLE | DESCRIPCIÓN
 --------------- | ------------
  Letalidad      | venenosa (p) o comestible(e)
  Forma del sombrebro o píleo | campana (b), cónica (c), convexa (x), plana (f), nudosa (k) o hundida (s)
  Cutícula o superficie del sombrero | fibroso (f), con surcos (g), escamosa (y) o lisa (s)
  Color del sombrero | marrón (n), ante (b), canela (c), gris (g), verde (r), rosa (p), morado (u), rojo (e), blanco (w) o amarillo (y)
  Escamas | verdadero (t) o falso (f)
  Olor | almendra (a), anís (l), creosota (c), pescado (y), asqueroso (f), mohoso (m), ninguno (n), acre(p) o picante (s)
  Fijación de las láminas | adjunto (a), descentente (d), libre (f) o entallado (n)
  Espacio entre láminas | cerca (c), atestado (w) o distante (d)
  Tamaño de las láminas | ancho (b) o estrecho (n)
  Color de las láminas | negro (k), marrón (n), ante (b), chocolate (h), gris (g), verde (r), naranja (o), rosa (p), morado (u), rojo (e), blanco (w) o amarillo (y)
  Forma del tallo | agrandado (e) o afilado (t)
  Tallo-raíz | bulboso (b), club (c), copa (u), igual (e), rizomorfos (z), enraizado (r) o faltante (?)
  Superficie del tallo por encima del anillo | fibroso (f), escamoso (y), sedoso (k) o liso (s)
  Superficie del tallo por debajo del anillo | fibroso (f), escamoso (y), sedoso (k) o liso (s)
  Color del tallo por encima del anillo | marrón (n), ante (b), canela (c), gris (g), naranja (o), rosa (p), rojo (e), blanco (w) o amarillo (y)
  Color del tallo por debajo del anillo | marrón (n), ante (b), canela (c), gris (g), naranja (o), rosa (p), rojo (e), blanco (w) o amarillo (y)
  Tipo de volva | parcial (p) o universal (u)
  Color del volva | marrón (n), naranja (o), blanco (w) o amarillo (y)
  Número de anillos | ninguno (n), uno (o) o dos (t)
  Tipo de anillo | telaraña (c), evanescente (e), abocinado (f), grande (l), ninguno (n), colgante (p), revestimiento (s) o zona (z)
  Color de las esporas | negro (k), marrón (n), ante (b), chocolate (h), verde (r), naranja (o), morado (u), blanco (w) o amarillo (y)
  Población | abundante (a), agrupada (c), numerosa (n), dispersa (s), varias (v) o solitaria (y)
  Habitat | pastos (g), hojas (l), prados (m), caminos (p), urbano (u), desechos (w) o bosques (d)

Vamos a llamar a las variables como la caracteristica que ejemplifican.
```{r nombre de variables}
colnames(datos.setas)=c("Letalidad","Forma_S","Cuticula","Color_S","Escamas","Olor","Fijacion_L","Espacio_L","Tamaño_L","Color_L","Forma_T","Tallo_raiz","Superficie_T1","Superficie_T2","Color_T1","Color_T2","Tipo_V","Color_V","N_anillos","Tipo_anillo","Color_esporas","Poblacion","Habitat")
```


#  Preprocesado de datos.

Para poder tranformar las variables en factor, lo haremos mediante **as.factor()** a todas las variables de los datos.
```{r factores, echo=FALSE}
#VARIABLE RESPUESTA
datos.setas$Letalidad=as.factor(datos.setas$Letalidad)
#VARIABLE 1
datos.setas$Forma_S=as.factor(datos.setas$Forma_S)
#VARIABLE 2
datos.setas$Cuticula=as.factor(datos.setas$Cuticula)
#VARIABLE 3
datos.setas$Color_S=as.factor(datos.setas$Color_S)
#VARIABLE 4
datos.setas$Escamas=as.factor(datos.setas$Escamas)
#VARIABLE 5
datos.setas$Olor=as.factor(datos.setas$Olor)
#VARIABLE 6
datos.setas$Fijacion_L=as.factor(datos.setas$Fijacion_L)
#VARIABLE 7
datos.setas$Espacio_L=as.factor(datos.setas$Espacio_L)
#VARIABLE 8
datos.setas$Tamaño_L=as.factor(datos.setas$Tamaño_L)
#VARIABLE 9
datos.setas$Color_L=as.factor(datos.setas$Color_L)
#VARIABLE 10
datos.setas$Forma_T=as.factor(datos.setas$Forma_T)
#VARIABLE 11
datos.setas$Tallo_raiz=as.factor(datos.setas$Tallo_raiz)
#VARIABLE 12
datos.setas$Superficie_T1=as.factor(datos.setas$Superficie_T1)
#VARIABLE 13
datos.setas$Superficie_T2=as.factor(datos.setas$Superficie_T2)
#VARIABLE 14
datos.setas$Color_T1=as.factor(datos.setas$Color_T1)
#VARIABLE 15
datos.setas$Color_T2=as.factor(datos.setas$Color_T2)
#VARIABLE 16
datos.setas$Tipo_V=as.factor(datos.setas$Tipo_V)
#VARIABLE 17
datos.setas$Color_V=as.factor(datos.setas$Color_V)
#VARIABLE 18
datos.setas$N_anillos=as.factor(datos.setas$N_anillos)
#VARIABLE 19
datos.setas$Tipo_anillo=as.factor(datos.setas$Tipo_anillo)
#VARIABLE 20
datos.setas$Color_esporas=as.factor(datos.setas$Color_esporas)
#VARIABLE 21
datos.setas$Poblacion=as.factor(datos.setas$Poblacion)
#VARIABLE 22
datos.setas$Habitat=as.factor(datos.setas$Habitat)
```

Ahora podemos ver mejor como son nuestros datos.
```{r resumen datos,echo=TRUE}
summary(datos.setas)
```
Una de las variables, **Tipo_v** (tipo de volva) con dos niveles distintos, parcial (p) y universal (u), podríamos eliminarla de nuestros datos pues todo la frecuencia solo está en uno de los niveles, luego no aporta información alguna para determinar si es venenosa o comestible.

```{r eliminar variable}
datos.setas=datos.setas[,-17]
```

Además, la variable **Fijacion_L** tendría solo dos niveles pues en el nivel descendente y entallado no aparecen en los datos y la variable **Espacio_L** también tiene dos niveles pues el nivel distante tampoco aparece, por ello las codificamos mediante unas variable binomiales.

Codificamos el resto de las variables originales de forma que obtendremos también nuevas variables binomiales, excepto las variables relacionadas con el color que las codificaremos siguiendo la escala de colores.
```{r codificación,echo=FALSE}
#Variable respuesta: venenosa-1 comestible-0
setas=data.frame(matrix(ncol=1))
colnames(setas)=c("Venenosas")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,1]=="e"){
    setas=rbind(setas,c(0))
  }
  if(datos.setas[i,1]=="p"){
    setas=rbind(setas,c(1))
  }
}

#Variable 1: forma del sombrero
sombrero=matrix(ncol=6)
colnames(sombrero)=c("Campana","Cónica","Convexa","Plana","Nudosa","Hundida")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,2]=="b"){
    sombrero=rbind(sombrero,c(1,0,0,0,0,0))
  }
  if(datos.setas[i,2]=="c"){
    sombrero=rbind(sombrero,c(0,1,0,0,0,0))
  }
  if(datos.setas[i,2]=="x"){
    sombrero=rbind(sombrero,c(0,0,1,0,0,0))
  }
  if(datos.setas[i,2]=="f"){
    sombrero=rbind(sombrero,c(0,0,0,1,0,0))
  }
  if(datos.setas[i,2]=="k"){
    sombrero=rbind(sombrero,c(0,0,0,0,1,0))
  }
  if(datos.setas[i,2]=="s"){
    sombrero=rbind(sombrero,c(0,0,0,0,0,1))
  }
}
setas=cbind(setas,sombrero)

#Variable 2: superficie del sombrero
superficie=matrix(ncol=4)
colnames(superficie)=c("Fibroso","Surcos","Escamoso","Liso")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,3]=="f"){
    superficie=rbind(superficie,c(1,0,0,0))
  }
  if(datos.setas[i,3]=="g"){
    superficie=rbind(superficie,c(0,1,0,0))
  }
  if(datos.setas[i,3]=="y"){
    superficie=rbind(superficie,c(0,0,1,0))
  }
  if(datos.setas[i,3]=="s"){
    superficie=rbind(superficie,c(0,0,0,1))
  }
}
setas=cbind(setas,superficie)

#Variable 3: color del sombrero
color_sombrero=matrix(ncol=10)
colnames(color_sombrero)=c("S_Marrón","S_Ante","S_Canela","S_Gris","S_Verde","S_Rosa","S_Morado","S_Rojo","S_Blanco","S_Amarillo")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,4]=="n"){
    color_sombrero=rbind(color_sombrero,c(1,0,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,4]=="b"){
    color_sombrero=rbind(color_sombrero,c(0,1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,4]=="c"){
    color_sombrero=rbind(color_sombrero,c(0,0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,4]=="g"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,4]=="r"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,4]=="p"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,4]=="u"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,4]=="e"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,4]=="w"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,4]=="y"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,color_sombrero)

#Variable 4: Escamas (true-1 false-0) prueba
escamas_S=matrix(ncol=1)
colnames(escamas_S)=c("Escamas")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,5]=="f"){
    escamas_S=rbind(escamas_S,c(0))
  }
  if(datos.setas[i,5]=="t"){
    escamas_S=rbind(escamas_S,c(1))
  }
}
setas=cbind(setas,escamas_S)

#Variable 5: olor
olor=matrix(ncol=9)
colnames(olor)=c("O_almendra","O_anís","O_creosota","O_pescado","O_asqueroso","O_mohoso","O_ninguno","O_acre","O_picante")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,6]=="a"){
    olor=rbind(olor,c(1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,6]=="l"){
    olor=rbind(olor,c(0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,6]=="c"){
    olor=rbind(olor,c(0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,6]=="y"){
    olor=rbind(olor,c(0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,6]=="f"){
    olor=rbind(olor,c(0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,6]=="m"){
    olor=rbind(olor,c(0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,6]=="n"){
    olor=rbind(olor,c(0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,6]=="p"){
    olor=rbind(olor,c(0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,6]=="s"){
    olor=rbind(olor,c(0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,olor)

#Varibale 6: fijación de láminas (adjunto-1 libre-0)
fijacion_laminas=matrix(ncol=1)
colnames(fijacion_laminas)=c("Adjunto/Libre")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,7]=="a"){
    fijacion_laminas=rbind(fijacion_laminas,c(1))
  }
  if(datos.setas[i,7]=="f"){
    fijacion_laminas=rbind(fijacion_laminas,c(0))
  }
}
setas=cbind(setas,fijacion_laminas)

#Variable 7: espacio entre láminas (cerca-1 atestado-0)
espacio_laminas=matrix(ncol=1)
colnames(espacio_laminas)=c("Cerca/Atestado")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,8]=="c"){
    espacio_laminas=rbind(espacio_laminas,c(1))
  }
  if(datos.setas[i,8]=="w"){
    espacio_laminas=rbind(espacio_laminas,c(0))
  }
}
setas=cbind(setas,espacio_laminas)

#Variable 8: tamaño de láminas (ancho-1 estrecho-0)
tamaño_laminas=matrix(ncol=1)
colnames(tamaño_laminas)=c("Ancho/Estrecho")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,9]=="b"){
    tamaño_laminas=rbind(tamaño_laminas,c(1))
  }
  if(datos.setas[i,9]=="n"){
    tamaño_laminas=rbind(tamaño_laminas,c(0))
  }
}
setas=cbind(setas,tamaño_laminas)

#Variable 9: color de láminas
color_laminas=matrix(ncol=12)
colnames(color_laminas)=c("L_Negro","L_Marrón","L_Canela","L_Chocolate","L_Gris","L_Verde","L_Naranja","L_Rosa","L_Morado","L_Rojo","L_Blanco","L_Amarillo")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,10]=="k"){
    color_laminas=rbind(color_laminas,c(1,0,0,0,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="n"){
    color_laminas=rbind(color_laminas,c(0,1,0,0,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="b"){
    color_laminas=rbind(color_laminas,c(0,0,1,0,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="h"){
    color_laminas=rbind(color_laminas,c(0,0,0,1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="g"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="r"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="o"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="p"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,10]=="u"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,10]=="e"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,10]=="w"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,10]=="y"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,color_laminas)

#Variable 10: forma del tallo (agrandado-1 afilado-0)
forma_tallo=matrix(ncol=1)
colnames(forma_tallo)=c("Agrandado/Afilado")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,11]=="e"){
    forma_tallo=rbind(forma_tallo,c(1))
  }
  if(datos.setas[i,11]=="t"){
    forma_tallo=rbind(forma_tallo,c(0))
  }
}
setas=cbind(setas,forma_tallo)

#Variable 11: tallo-raíz
tallo_r=matrix(ncol=7)
colnames(tallo_r)=c("TR_bulboso","TR_club","TR_copa","TR_igual","TR_rizomorfos","TR_enraizado","TR_faltante")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,12]=="b"){
    tallo_r=rbind(tallo_r,c(1,0,0,0,0,0,0))
  }
  if(datos.setas[i,12]=="c"){
    tallo_r=rbind(tallo_r,c(0,1,0,0,0,0,0))
  }
  if(datos.setas[i,12]=="u"){
    tallo_r=rbind(tallo_r,c(0,0,1,0,0,0,0))
  }
  if(datos.setas[i,12]=="e"){
    tallo_r=rbind(tallo_r,c(0,0,0,1,0,0,0))
  }
  if(datos.setas[i,12]=="z"){
    tallo_r=rbind(tallo_r,c(0,0,0,0,1,0,0))
  }
  if(datos.setas[i,12]=="r"){
    tallo_r=rbind(tallo_r,c(0,0,0,0,0,1,0))
  }
  if(datos.setas[i,12]=="?"){
    tallo_r=rbind(tallo_r,c(0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,tallo_r)

#Variable 12: superficie del tallo por encima del anillo
superficiet1=matrix(ncol=4)
colnames(superficiet1)=c("ST1_Fibroso","ST1_Escamoso","ST1_Sedoso","ST1_Liso")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,13]=="f"){
    superficiet1=rbind(superficiet1,c(1,0,0,0))
  }
  if(datos.setas[i,13]=="y"){
    superficiet1=rbind(superficiet1,c(0,1,0,0))
  }
  if(datos.setas[i,13]=="k"){
    superficiet1=rbind(superficiet1,c(0,0,1,0))
  }
  if(datos.setas[i,13]=="s"){
    superficiet1=rbind(superficiet1,c(0,0,0,1))
  }
}
setas=cbind(setas,superficiet1)

#Variable 13: superficie del tallo por debajo del anillo
superficiet2=matrix(ncol=4)
colnames(superficiet2)=c("ST2_Fibroso","ST2_Escamoso","ST2_Sedoso","ST2_Liso")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,14]=="f"){
    superficiet2=rbind(superficiet2,c(1,0,0,0))
  }
  if(datos.setas[i,14]=="y"){
    superficiet2=rbind(superficiet2,c(0,1,0,0))
  }
  if(datos.setas[i,14]=="k"){
    superficiet2=rbind(superficiet2,c(0,0,1,0))
  }
  if(datos.setas[i,14]=="s"){
    superficiet2=rbind(superficiet2,c(0,0,0,1))
  }
}
setas=cbind(setas,superficiet2)

#Variable 14: color del tallo por encima del anillo
color.t1=matrix(ncol=9)
colnames(color.t1)=c("CT1_marron","CT1_ante","CT1_canela","CT1_gris","CT1_naranja","CT1_rosa","CT1_rojo","CT1_blanco","CT1_amarillo")
for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,15]=="n"){
    color.t1=rbind(color.t1,c(1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,15]=="b"){
    color.t1=rbind(color.t1,c(0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,15]=="c"){
    color.t1=rbind(color.t1,c(0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,15]=="g"){
    color.t1=rbind(color.t1,c(0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,15]=="o"){
    color.t1=rbind(color.t1,c(0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,15]=="p"){
    color.t1=rbind(color.t1,c(0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,15]=="e"){
    color.t1=rbind(color.t1,c(0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,15]=="w"){
    color.t1=rbind(color.t1,c(0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,15]=="y"){
    color.t1=rbind(color.t1,c(0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,color.t1)
  


#Variable 15: color del tallo por debajo del anillo
color.t2=matrix(ncol=9)
colnames(color.t2)=c("CT2_marron","CT2_ante","CT2_canela","CT2_gris","CT2_naranja","CT2_rosa","CT2_rojo","CT2_blanco","CT2_amarillo")
for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,16]=="n"){
    color.t2=rbind(color.t2,c(1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,16]=="b"){
    color.t2=rbind(color.t2,c(0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,16]=="c"){
    color.t2=rbind(color.t2,c(0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,16]=="g"){
    color.t2=rbind(color.t2,c(0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,16]=="o"){
    color.t2=rbind(color.t2,c(0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,16]=="p"){
    color.t2=rbind(color.t2,c(0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,16]=="e"){
    color.t2=rbind(color.t2,c(0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,16]=="w"){
    color.t2=rbind(color.t2,c(0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,16]=="y"){
    color.t2=rbind(color.t2,c(0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,color.t2)

#Variable 16: color de la volva
color_volva=matrix(ncol=4)
colnames(color_volva)=c("V_Marrón","V_Naranja","V_Blanco","V_Amarillo")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,17]=="n"){
    color_volva=rbind(color_volva,c(1,0,0,0))
  }
  if(datos.setas[i,17]=="o"){
    color_volva=rbind(color_volva,c(0,1,0,0))
  }
  if(datos.setas[i,17]=="w"){
    color_volva=rbind(color_volva,c(0,0,1,0))
  }
  if(datos.setas[i,17]=="y"){
    color_volva=rbind(color_volva,c(0,0,0,1))
  }
}
setas=cbind(setas,color_volva)

#Variable 17: número de anillos
nanillos=matrix(ncol=3)
colnames(nanillos)=c("NA_0","NA_1","NA_2")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,18]=="n"){
    nanillos=rbind(nanillos,c(1,0,0))
  }
  if(datos.setas[i,18]=="o"){
    nanillos=rbind(nanillos,c(0,1,0))
  }
  if(datos.setas[i,18]=="t"){
    nanillos=rbind(nanillos,c(0,0,1))
  }
}
setas=cbind(setas,nanillos)

#Variable 18: tipo de anillo
tanillo=matrix(ncol=8)
colnames(tanillo)=c("TA_Telaraña","TA_Evanescente","TA_Abocinado","TA_Grande","TA_Ninguno","TA_Colgante","TA_Revestimiento","TA_Zona")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,19]=="c"){
    tanillo=rbind(tanillo,c(1,0,0,0,0,0,0))
  }
  if(datos.setas[i,19]=="e"){
    tanillo=rbind(tanillo,c(0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,19]=="f"){
    tanillo=rbind(tanillo,c(0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,19]=="l"){
    tanillo=rbind(tanillo,c(0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,19]=="n"){
    tanillo=rbind(tanillo,c(0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,19]=="p"){
    tanillo=rbind(tanillo,c(0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,19]=="s"){
    tanillo=rbind(tanillo,c(0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,19]=="z"){
    tanillo=rbind(tanillo,c(0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,tanillo)

#Variable 19: color de las esporas
color.e=matrix(ncol=9)
colnames(color.e)=c("CE_negro","CE_marron","CE_ante","CE_chocolate","CE_verde","CE_naranja","CE_morado","CE_blanco","CE_amarillo")
for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,20]=="k"){
    color.e=rbind(color.e,c(1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,20]=="n"){
    color.e=rbind(color.e,c(0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,20]=="b"){
    color.e=rbind(color.e,c(0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,20]=="h"){
    color.e=rbind(color.e,c(0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,20]=="r"){
    color.e=rbind(color.e,c(0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,20]=="o"){
    color.e=rbind(color.e,c(0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,20]=="u"){
    color.e=rbind(color.e,c(0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,20]=="w"){
    color.e=rbind(color.e,c(0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,20]=="y"){
    color.e=rbind(color.e,c(0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,color.e)

#Variable 20: población
poblation=matrix(ncol=6)
colnames(poblation)=c("Abundante", "Agrupada", "Numerosa", "Dispersa", "Varias", "Solitaria")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,21]=="a"){
    poblation=rbind(poblation,c(1,0,0,0,0,0))
  }
  if(datos.setas[i,21]=="c"){
    poblation=rbind(poblation,c(0,1,0,0,0,0))
  }
  if(datos.setas[i,21]=="n"){
    poblation=rbind(poblation,c(0,0,1,0,0,0))
  }
  if(datos.setas[i,21]=="s"){
    poblation=rbind(poblation,c(0,0,0,1,0,0))
  }
  if(datos.setas[i,21]=="v"){
    poblation=rbind(poblation,c(0,0,0,0,1,0))
  }
  if(datos.setas[i,21]=="y"){
    poblation=rbind(poblation,c(0,0,0,0,0,1))
  }
}
setas=cbind(setas,poblation)

#Variable 21: habitat
habita=matrix(ncol=7)
colnames(habita)=c("Bosques", "Pastos", "Hojas", "Prados", "Caminos", "Urbano", "Desechos")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,22]=="d"){
    habita=rbind(habita,c(1,0,0,0,0,0,0))
  }
  if(datos.setas[i,22]=="g"){
    habita=rbind(habita,c(0,1,0,0,0,0,0))
  }
  if(datos.setas[i,22]=="l"){
    habita=rbind(habita,c(0,0,1,0,0,0,0))
  }
  if(datos.setas[i,22]=="m"){
    habita=rbind(habita,c(0,0,0,1,0,0,0))
  }
  if(datos.setas[i,22]=="p"){
    habita=rbind(habita,c(0,0,0,0,1,0,0))
  }
  if(datos.setas[i,22]=="u"){
    habita=rbind(habita,c(0,0,0,0,0,1,0))
  }
  if(datos.setas[i,22]=="w"){
    habita=rbind(habita,c(0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,habita)

setas=setas[-1,]
rownames(setas)=as.character(seq(1:dim(datos.setas)[1]))
```

```{r datos codificados,echo=TRUE}
#6 primeras observaciones de los datos ya codificados
head(setas)

#Dimensión
dim(setas)

```

##  Particiones.

```{r particiones}
n_totales=dim(datos.setas)[1]
n_train=floor(n_totales*0.6) # el 60% de los datos los utilizamos para entrenar los modelos
n_test=floor(n_totales*0.2) # el 20% para test
n_validacion=n_totales-n_train-n_test

set.seed(34735)

indices_totales=seq(1:n_totales)
indices_train=sort(sample(indices_totales,n_train))
indices_test=sort(sample(indices_totales[-indices_train],n_test))
indices_validacion=indices_totales[-c(indices_train,indices_test)]


setas_train=setas[indices_train,]
setas_test=setas[indices_test,]
setas_validacion=setas[indices_validacion,]

```


##  EDA. Exploratory Data Analysis.

### Letalidad:
La variable **letalidad** tiene dos niveles distintos, venenosa (p) o comestible (e), la frecuencia relativa correspondiente a nuestros datos es:
```{r proporcion, echo=TRUE}
#Tabla:
table(setas_train$Venenosas)
#Tabla de frecuencias:
prop.table(table(setas_train$Venenosas))
#Gráfico
barplot(table(setas_train$Venenosas),main="Letalidad",ylab="Número de setas",col=c("blue","magenta"),names.arg=c("Comestible","Venenosa"))
```



##  Correlación entre las variables.

Vamos a comprobar si existe alguna correlación entre las distintas variables. 

### Forma del sombrero (Forma_S)

```{r forma del sombrero,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~forma del sombrero
table(datos.setas$Letalidad,datos.setas$Forma_S)
#Gráfico letalidad~forma del sombrero
barplot(table(datos.setas$Letalidad,datos.setas$Forma_S),main="Letalidad vs Forma del sombrero",xlab="Forma",ylab="Número de setas",names.arg=c("Campana", "Cónica", "Plana", "Nudosa", "Hundida", "Convexa"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Forma_S))
```


### Cutícula

```{r cuticula,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~cuticula
table(datos.setas$Letalidad,datos.setas$Cuticula)
#Gráfico letalidad~cuticula
barplot(table(datos.setas$Letalidad,datos.setas$Cuticula),main="Letalidad vs Cuticula",xlab="Cuticula",ylab="Número de setas",names.arg=c("Fibroso", "Con surcos", "Lisa", "Escamosa"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Cuticula))
```


### Color del sombrero (Color_S)

```{r color del sombrero,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color del sombrero
table(datos.setas$Letalidad,datos.setas$Color_S)
#Gráfico letalidad~color del sombrero
barplot(table(datos.setas$Letalidad,datos.setas$Color_S),main="Letalidad vs Color del sombrero",xlab="Color",ylab="Número de setas",names.arg=c("Ante", "Canela", "Rojo", "Gris","Marrón","Rosa","Verde","Morado","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_S))
```


### Escamas

```{r escamas,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~escamas
table(datos.setas$Letalidad,datos.setas$Escamas)
#Gráfico letalidad~escamas
barplot(table(datos.setas$Letalidad,datos.setas$Escamas),main="Letalidad vs Escamas",xlab="Escamas",ylab="Número de setas",names.arg=c("Sin escamas", "Con escamas"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Escamas))
```


### Olor

```{r olor setas,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~olor
table(datos.setas$Letalidad,datos.setas$Olor)
#Gráfico letalidad~olor
barplot(table(datos.setas$Letalidad,datos.setas$Olor),main="Letalidad vs Olor",xlab="Olor",ylab="Número de setas",names.arg=c("Almendra", "Creosota","Asqueroso","Anís","Mohoso","Ninguno","Acre","Picante","Pescado"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Olor))
```
Podemos observar que la variable **olor** se distribuye entre los distintos tipos de olor de forma binaria, es decir, todas las setas que presentan un olor del tipo *creosota, asqueroso, mohoso, acre, picante o pesacado* son venenosas mientras que si presentan un olor del tipo *almendar, anís * son comestibles, mientras que si es *ninguno* el olor tienes una proporción de 97% de que sea comestible. 
```{r proporcion olor,echo=TRUE}
#Proporción según olor sea ninguno
prop.table(table(datos.setas$Letalidad,datos.setas$Olor)[,6])
```
Entonces modríamos cambiar la codificación hecha anteriormente y tener solo una variable codificada de forma binaria de tal forma que para los olores que producen que la seta sea venenosa darles el valor 1 y para los que no, darles el valor 0.


### Fijación de las láminas (Fijacion_L)

```{r fijacion,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~fijación de las láminas
table(datos.setas$Letalidad,datos.setas$Fijacion_L)
#Gráfico letalidad~fijación de las láminas
barplot(table(datos.setas$Letalidad,datos.setas$Fijacion_L),main="Letalidad vs Fijación de las láminas",xlab="Fijación",ylab="Número de setas",names.arg=c("Adjunto", "Libre"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Fijacion_L))
```
Podemos ver que la proporción de que la seta sea venenosa o comestible según la fijación de las láminas en el caso de que estén libre es casi del 50% mientras que si están adjuntas la proporción cambia a un 94% frente a un 6%, comestible o venenosa, respectivamente.
```{r proporcion fijacion,echo=TRUE}
#Proporción según fijacion sea adjunto
prop.table(table(datos.setas$Letalidad,datos.setas$Fijacion_L)[,1])*100

#Proporción según fijacion sea libre
prop.table(table(datos.setas$Letalidad,datos.setas$Fijacion_L)[,2])*100
```


### Espacio entre láminas (Espacio_L)

```{r espacio,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~espacio entre láminas
table(datos.setas$Letalidad,datos.setas$Espacio_L)
#Gráfico letalidad~espacio entre láminas
barplot(table(datos.setas$Letalidad,datos.setas$Espacio_L),main="Letalidad vs Espacio entre láminas",xlab="Espacio",ylab="Número de setas",names.arg=c("Cerca", "Atestado"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Espacio_L))
```
Podemos ver que ocurre algo parecido que en la variable **fijacion_L**, la proporción de que la seta sea venenosa o comestible según el espacio entre las láminas en el caso de que estén cerca es casi del 50% mientras que si están atestado la proporción cambia a un 92% frente a un 8%, comestible o venenosa, respectivamente.
```{r proporcion espacio,echo=TRUE}
#Proporción según espacio sea cerca
prop.table(table(datos.setas$Letalidad,datos.setas$Espacio_L)[,1])*100

#Proporción según espacio sea atestado
prop.table(table(datos.setas$Letalidad,datos.setas$Espacio_L)[,2])*100
```


### Tamaño de las láminas (Tamaño_L)

```{r tamaño,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~tamaño de las láminas
table(datos.setas$Letalidad,datos.setas$Tamaño_L)
#Gráfico letalidad~tamaño de las láminas
barplot(table(datos.setas$Letalidad,datos.setas$Tamaño_L),main="Letalidad vs Tamaño de las láminas",xlab="Tamaño",ylab="Número de setas",names.arg=c("Ancho", "Estrecho"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Tamaño_L))
```
Podemos ver que la proporción de que la seta sea venenosa o comestible según el tamaño de las láminas en el caso de que sea ancha es del 30% frente a 70%, respectivamente, mientras que si es estrecho la proporción cambia a un 11.5% frente a un 88.5%, respectivamente.
```{r proporcion tamaño,echo=TRUE}
#Proporción según tamaño sea ancho
prop.table(table(datos.setas$Letalidad,datos.setas$Tamaño_L)[,1])*100

#Proporción según tamaño sea estrecho
prop.table(table(datos.setas$Letalidad,datos.setas$Tamaño_L)[,2])*100
```


### Color de las láminas (Color_L)

```{r color laminas,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color de las láminas
table(datos.setas$Letalidad,datos.setas$Color_L)
#Gráfico letalidad~color de las láminas
barplot(table(datos.setas$Letalidad,datos.setas$Color_L),main="Letalidad vs Color de las láminas",xlab="Color",ylab="Número de setas",names.arg=c("Ante", "Rojo","Gris","Chocolate","Negro","Marrón","Naranja","Rosa","Verde","Morado","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_L))
```


### Forma del tallo (Forma_T)

```{r forma tallo,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~forma del tallo
table(datos.setas$Letalidad,datos.setas$Forma_T)
#Gráfico letalidad~forma del tallo
barplot(table(datos.setas$Letalidad,datos.setas$Forma_T),main="Letalidad vs Forma del tallo",xlab="Tallo",ylab="Número de setas",names.arg=c("Agrandado", "Afilado"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Forma_T))
```
Podemos ver que la proporción de que la seta sea venenosa o comestible según el forma del tallo es casi del 50% en ambos formas del tallo
```{r proporcion forma,echo=TRUE}
#Proporción según forma sea agrandado
prop.table(table(datos.setas$Letalidad,datos.setas$Forma_T)[,1])*100

#Proporción según forma sea afilado
prop.table(table(datos.setas$Letalidad,datos.setas$Forma_T)[,2])*100
```


### Tallo-Raíz (Tallo_raiz)

```{r tallo raiz,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~tallo-raiz
table(datos.setas$Letalidad,datos.setas$Tallo_raiz)
#Gráfico letalidad~tallo-raiz
barplot(table(datos.setas$Letalidad,datos.setas$Tallo_raiz),main="Letalidad vs Tallo-Raiz",xlab="Tallo-Raiz",ylab="Número de setas",names.arg=c("Faltante", "Bulboso","Club","Igual","Enraizado"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Tallo_raiz))
```


### Superficie del tallo por encima del anillo (Superficie_T1)

```{r superficie t1,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~supercifie del tallo por encima del anillo
table(datos.setas$Letalidad,datos.setas$Superficie_T1)
#Gráfico letalidad~superficie del tallo por encima del anillo
barplot(table(datos.setas$Letalidad,datos.setas$Superficie_T1),main="Letalidad vs Tallo por encima del anillo",xlab="Superficie",ylab="Número de setas",names.arg=c("Fibroso", "Sedoso","Liso","Escamoso"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Superficie_T1))
```


### Superficie del tallo por debajo del anillo (Superficie_T2)

```{r superficie t2,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~supercifie del tallo por debajo del anillo
table(datos.setas$Letalidad,datos.setas$Superficie_T2)
#Gráfico letalidad~superficie del tallo por debajo del anillo
barplot(table(datos.setas$Letalidad,datos.setas$Superficie_T2),main="Letalidad vs Tallo por debajo del anillo",xlab="Superficie",ylab="Número de setas",names.arg=c("Fibroso", "Sedoso","Liso","Escamoso"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Superficie_T2))
```


### Color del tallo por encima del anillo (Color_T1)

```{r color t1,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color del tallo por encima del anillo
table(datos.setas$Letalidad,datos.setas$Color_T1)
#Gráfico letalidad~color del tallo por encima del anillo
barplot(table(datos.setas$Letalidad,datos.setas$Color_T1),main="Letalidad vs Tallo por encima del anillos",xlab="Color",ylab="Número de setas",names.arg=c("Ante", "Canela","Rojo","Gris","Marrón","Naranja","Rosa","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_T1))
```


### Color del tallo por debajo del anillo (Color_T2)

```{r color t2,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color del tallo por debajo del anillo
table(datos.setas$Letalidad,datos.setas$Color_T2)
#Gráfico letalidad~color del tallo por debajo del anillo
barplot(table(datos.setas$Letalidad,datos.setas$Color_T2),main="Letalidad vs Tallo por debajo del anillos",xlab="Color",ylab="Número de setas",names.arg=c("Ante", "Canela","Rojo","Gris","Marrón","Naranja","Rosa","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_T2))
```


### Color del volva (Color_V)

```{r color volva,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color del volva
table(datos.setas$Letalidad,datos.setas$Color_V)
#Gráfico letalidad~color del volva
barplot(table(datos.setas$Letalidad,datos.setas$Color_V),main="Letalidad vs Volva",xlab="Color",ylab="Número de setas",names.arg=c("Marrón", "Naranja","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_V))
```


### Número de anillos (N_anillos)

```{r numero anillos,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~numero de anillos
table(datos.setas$Letalidad,datos.setas$N_anillos)
#Gráfico letalidad~numero de anillos
barplot(table(datos.setas$Letalidad,datos.setas$N_anillos),main="Letalidad vs Anillos",xlab="Número",ylab="Número de setas",names.arg=c("Ninguno", "Uno","Dos"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$N_anillos))
```


### Tipo de anillo (Tipo_anillo)

```{r tipo anillos,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~tipo de anillo
table(datos.setas$Letalidad,datos.setas$Tipo_anillo)
#Gráfico letalidad~tipo de anillo
barplot(table(datos.setas$Letalidad,datos.setas$Tipo_anillo),main="Letalidad vs Anillo",xlab="Tipo",ylab="Número de setas",names.arg=c("Evanescente", "Abocinado","Grande","Ninguno","Colgante"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Tipo_anillo))
```


### Color de las esporas

```{r color esporas,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color de las esporas
table(datos.setas$Letalidad,datos.setas$Color_esporas)
#Gráfico letalidad~color de las esporas
barplot(table(datos.setas$Letalidad,datos.setas$Color_esporas),main="Letalidad vs Esporas",xlab="Color",ylab="Número de setas",names.arg=c("Ante", "Chocolate","Negro","Marrón","Naranja","Verde","Morado","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_esporas))
```
Podemos observar que aquellas setas que tengan el color de las esporas *ante, naranja, morado o amarillo* son comestibles.


### Población

```{r poblacion,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~poblacion
table(datos.setas$Letalidad,datos.setas$Poblacion)
#Gráfico letalidad~poblacion
barplot(table(datos.setas$Letalidad,datos.setas$Poblacion),main="Letalidad",xlab="Poblacion",ylab="Número de setas",names.arg=c("abundante", "agrupada", "numerosa", "dispersa", "varias", "solitaria"),col=c("blue","magenta"))
#legend(x = "topright", legend = c("Comestible","Venenosa"), fill = c("blue", "magenta"))
```


### Habitat

```{r habitat,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~habitat
table(datos.setas$Letalidad,datos.setas$Habitat)
#Gráfico letalidad~habitat
barplot(table(datos.setas$Letalidad,datos.setas$Habitat),main="Letalidad",xlab="Habitat",ylab="Número de setas",names.arg=c("bosques", "pastos", "hojas", "prados", "caminos", "urbano", "desechos"),col=c("blue","magenta"))
#legend(x = "topright", legend = c("Comestible","Venenosa"), fill = c("blue", "magenta"))
```

## Componentes principales

Dada la naturaleza de nuestros datos, no nos es posible usar las distancias euclideas como medida para comparar como de cerca están dos observaciones, por ellos debemos usar otras medidas de similitud. Para ello, usamos la siguiente tabla de contingencia:

 |1|0
-|-|-
1|a|b
0|c|d

Hacemos un intento de calcular nuestra propia medida de similitud mediante un algoritmo, pero vemos que el proceso es muy largo debido a la dimensión de la matriz de los datos, por ellos buscamos alguna función predeterminada en R que sea capaz de hacerla.
```{r intento medida de similitud dice1,eval=FALSE}
#i observacion1, j observacion2, k caracteristica
i=1
n=dim(setas_train)[1]
k=dim(setas_train)[2]
distancia_dice=diag(n)
while(i<n){
  j=i+1
  while(j<=n) {
    #Calculo de similitud
    a=sum(setas_train[i,2:k]*setas_train[j,2:k])
    d=sum((1-setas_train[i,2:k])*(1-setas_train[j,2:k]))
    distancia_dice[i,j]=((2*a)/(a+(k-d)))
    distancia_dice[j,i]=((2*a)/(a+(k-d)))
    j=j+1
  }
  i=i+1
}
```

Encontramos la función *designdist()* que nos permite definir nuestra propia medida de similitud. La cebezara de está función será
$$designdist(datos,metodo,abcd)$$
donde **datos** es nuestra matriz codificada de forma binaria, **metodo** escribiremos la expresión de la medida de similitud que queramos y **abcd=TRUE** usa la tabla de contingencia para datos binarios.

```{r intento medida de similitud dice1,eval=FALSE}
designdist(setas_train[1:10,10:117],"(2*a)/(2*a+b+c)",abcd=TRUE)
```

Finalmente nos decantaremos por la función *distance()* de la librería **_philentropy_**, a la cual debemos introducirle como parámetros la matriz con nuestros datos codificados y el método por el cual queremos calcular la distancia, en nuestro caso, utilizamos *method="dice"*, cuya expresión matemática es exactamente:
$$d = \dfrac{\sum(P_i − Q_i)^2}{(\sum P_i^2 + \sum Q_i^2)}$$
```{r distancias,echo=TRUE,warning=FALSE}
#Distancia Dice
distancia_dice=distance(setas_train[,2:117],method="dice")
```

Una vez calculada nuestra medida de similitud, buscamos encontrar unos puntos que nos sirvan como referentes, para ellos calculamos una cierta cantidad de medoides que los calcularemos trabajando con particiones e intentan minimizar la distancia entre puntos de un grupo y otro punto designado como el centro de ese grupo. A diferencia de *kmeans()*, *fastkmed()* escoge como medoides puntos de los datos y trabaja con una métrica arbitraria de distancias.

```{r medoides,echo=TRUE}
#Cálculo de los medoides: 
k50=fastkmed(distancia_dice,ncluster=50)
distancia_medoides=distancia_dice[k50$medoid,k50$medoid]
#Proporción de los medoides:
table(setas_train$Venenosas[k50$medoid])
```
Podemos ver que de los 50 medoides que hemos calculado, necesitamos 19 para explicar las setas no venenosas mientras que solo 11 para las venenosas. La proporción se mantiene cogiendo un número distinto de medoides, siendo entre un 70%-80% de los medoides setas no venenosas.

Con estos medoides podemos realizar un análisis de componente principales.
```{r pca,echo=TRUE}
#Análisis Componentes principales:
pca.50=prcomp(distancia_medoides)
plot(pca.50)
plot(pca.50$x,col=setas_train$Venenosas[k50$medoid]+1,pch=19)
```
Podemos ver  como la variabilidad de los datos se explica mayoritariamente por la primera componente principal  PC1, aunque nos quedaremos con las dos primeras.

En la otra gráfica, vemos como los medoides que se encuentra con un valor de $PC1<0$ son setas no venenosas, si $PC1>1.5$ las setas son venenosas, mientras que en el intervalo $PC1\in(0,1.5)$ tenemos setas venenosas y no venenosas.

Las dos gráficas siguientes son la misma que la anterior, pero las realizamos para ver si algunos de los puntos está superpuesto por otro. Esto solo ocurre en un punto.

```{r grafico pca alternativo,echo=TRUE}
#Gráfico:
##Indices de los medoides según toxicidad:
comestible=which(setas_train[k50$medoid,1]==0)
no.comestibles=which(setas_train[k50$medoid,1]==1)

par(mfrow=c(1,2))
plot(pca.50$x)
points(pca.50$x[comestible,1:2],col=1,pch=19)
points(pca.50$x[no.comestibles,1:2],col=2,pch=19)
plot(pca.50$x)
points(pca.50$x[no.comestibles,1:2],col=2,pch=19)
points(pca.50$x[comestible,1:2],col=1,pch=19)
```

## Análisis Cluster

```{r cluster,echo=TRUE}
#Números de clusters
SSW <- vector(mode = "numeric", length = 15)
n=dim(pca.50$x)[1]
#Variabilidad de todos los datos, es decir, todos los datos como un único cluster
SSW[1] <- (n - 1) * sum(apply(pca.50$x,2,var)) 

#Variabilidad de cada modelo, desde 2 clusters hasta 15 clusters
for (i in 2:15) SSW[i] <- sum(kmeans(pca.50$x,centers=i,nstart=25)$withinss)

#Dibujamos un gráfico con el resultado
plot(1:15, SSW, type="b", xlab="Number of Clusters", ylab="Sum of squares within groups",pch=19, col="steelblue4")


#Análisis cluster
clusters.datos=kmeans(pca.50$x,centers=5,nstart=25)
table(clusters.datos$cluster,setas_train$Venenosas[k50$medoid])
```
Vemos que tras realizar el análisis cluster con 5 grupos, tenemos bastante bien clasificados los tipos de setas pero uno de los cluster están mezcladas, luego habría que estudiar ese para ver como diferenciar las venenosas de las comestibles.
\vspace(3mm)


Pero trabajar solo con los 50 medoides podemos perder mucha información, por ellos rehacemos todo lo anterior pero ahora aplicaremos el análisis de componentes principales a la distancia de todas las observaciones con los 50 medoides.

```{r medoides a observaciones,echo=TRUE}
distancia_trainM=distancia_dice[,k50$medoid]

#Análsiis de componentes principales
pca.train=prcomp(distancia_trainM)
plot(pca.train)
plot(pca.train$x,col=setas_train$Venenosas+1,pch=19)

#Gráfico alternativo
comestible=which(setas_train[,1]==0)
no.comestibles=which(setas_train[,1]==1)

par(mfrow=c(1,2))
plot(pca.train$x)
points(pca.train$x[comestible,1:2],col=1,pch=19)
points(pca.train$x[no.comestibles,1:2],col=2,pch=19)
plot(pca.train$x)
points(pca.train$x[no.comestibles,1:2],col=2,pch=19)
points(pca.train$x[comestible,1:2],col=1,pch=19)
```

Observamos algo bastante parecido a lo obtenido en el análisis anterior, dos zonas bastante bien diferenciadas y otra zona donde coinciden las stas venenosas y las comestibles. Luego podemos llegar a suponer que el número de cluster necesarios serían 5 como ocurría en el análisis anterior, pero vamos a probar con un número mayor de cluster para intentar clasificar lo mejor posible la nube de puntos de $PC1\in(-1,2)$ y $PC2\in(-1,0.5)$. 

```{r cluster con distancia de los medoides,echo=TRUE}
#Análisis cluster
clusters.datos.train=kmeans(pca.train$x,centers=8,nstart=25)
table(clusters.datos.train$cluster,setas_train$Venenosas[])

##PREGUNTAR JAVIER/ISAAC
clusplot(pca.train$x, clusters.datos.train$cluster, color=TRUE, shade=TRUE, labels=1,lines=0)
```
Vemos que tras realizar el análisis cluster con 8 grupos, no obtenemos tan claramente la clasificación de setas pero volvemos a tener dos grupos bien diferenciados, que son los que vemos en el gráfico del análisis de componentes principales, el resto están mezclados entre los cluster y habría que analizar cada uno de ellos para poder obtener alguna información más.


Esto nos indica que quizás no sean necesarios 50 medoides para realizar los análisis y podríamos obtener un resultado parecido con una cantidad menor. Por ello, vamos a probar a hacer todo pero con una cantidad más reducida de medoides. Tomamos un valor entre 10 y 20 medoides.

```{r medoides 15,echo=TRUE}
#Cálculo de los medoides: 
k15=fastkmed(distancia_dice,ncluster=15)
#Proporción de los medoides:
table(setas_train$Venenosas[k15$medoid])

distancia_trainM15=distancia_dice[,k15$medoid]

#Análsiis de componentes principales
pca.train15=prcomp(distancia_trainM15)
plot(pca.train15)
plot(pca.train15$x,col=setas_train$Venenosas+1,pch=19)

#Gráfico alternativo
comestible=which(setas_train[,1]==0)
no.comestibles=which(setas_train[,1]==1)

par(mfrow=c(1,2))
plot(pca.train15$x)
points(pca.train15$x[comestible,1:2],col=1,pch=19)
points(pca.train15$x[no.comestibles,1:2],col=2,pch=19)
plot(pca.train15$x)
points(pca.train15$x[no.comestibles,1:2],col=2,pch=19)
points(pca.train15$x[comestible,1:2],col=1,pch=19)


#Análisis cluster
clusters.datos.train15=kmeans(pca.train15$x,centers=8,nstart=25)
table(clusters.datos.train15$cluster,setas_train$Venenosas[])
```

```{r medoides 10,echo=TRUE}
#Cálculo de los medoides: 
k10=fastkmed(distancia_dice,ncluster=10)
#Proporción de los medoides:
table(setas_train$Venenosas[k10$medoid])

distancia_trainM10=distancia_dice[,k10$medoid]

#Análsiis de componentes principales
pca.train10=prcomp(distancia_trainM10)
plot(pca.train10)
plot(pca.train10$x,col=setas_train$Venenosas+1,pch=19)

#Gráfico alternativo
comestible=which(setas_train[,1]==0)
no.comestibles=which(setas_train[,1]==1)

par(mfrow=c(1,2))
plot(pca.train10$x)
points(pca.train10$x[comestible,1:2],col=1,pch=19)
points(pca.train10$x[no.comestibles,1:2],col=2,pch=19)
plot(pca.train10$x)
points(pca.train10$x[no.comestibles,1:2],col=2,pch=19)
points(pca.train10$x[comestible,1:2],col=1,pch=19)


#Análisis cluster
clusters.datos.train10=kmeans(pca.train10$x,centers=8,nstart=25)
table(clusters.datos.train10$cluster,setas_train$Venenosas[])
```

```{r medoides 20,echo=TRUE}
#Cálculo de los medoides: 
k20=fastkmed(distancia_dice,ncluster=20)
#Proporción de los medoides:
table(setas_train$Venenosas[k20$medoid])

distancia_trainM20=distancia_dice[,k20$medoid]

#Análsiis de componentes principales
pca.train20=prcomp(distancia_trainM20)
plot(pca.train20)
plot(pca.train20$x,col=setas_train$Venenosas+1,pch=19)

#Gráfico alternativo
comestible=which(setas_train[,1]==0)
no.comestibles=which(setas_train[,1]==1)

par(mfrow=c(1,2))
plot(pca.train20$x)
points(pca.train20$x[comestible,1:2],col=1,pch=19)
points(pca.train20$x[no.comestibles,1:2],col=2,pch=19)
plot(pca.train20$x)
points(pca.train20$x[no.comestibles,1:2],col=2,pch=19)
points(pca.train20$x[comestible,1:2],col=1,pch=19)


#Análisis cluster
clusters.datos.train20=kmeans(pca.train20$x,centers=8,nstart=25)
table(clusters.datos.train20$cluster,setas_train$Venenosas[])
```

Los resultados son bastantes parecidos cuando cogemos una cantidad de medoides entre 10 y 20. 


A pesar de ellos, nos quedaremos con 50 medoides, para tener más información.



##  Transformación de variables

Las variables no necesitan ninguna modificación adicional, pues ya las hemos codificado anteriormente.

##  Imputacion de datos (datos faltantes)

No se requiere de imputación de datos, pues no hay datos faltantes en ninguna de las variables.

#  Modelado

##  k-NN

El algoritmo clasifica cada dato nuevo en el grupo que corresponda, según tenga k vecinos más cerca de un grupo o de otro. Es decir, calcula la distancia del elemento nuevo a cada uno de los existentes, y ordena dichas distancias de menor a mayor para ir seleccionando el grupo al que pertenecer. Este grupo será, por tanto, el de mayor frecuencia con menores distancias.

```{r knn,echo=TRUE}
#Buscamos los vecinos más cercanos
prediccion_knn=knn(setas_train[k50$medoid,],setas_test,cl=setas_train$Venenosas[k50$medoid],k=1)
table(prediccion_knn,setas_test$Venenosas)

# Medidas de precisión
accuracy = sum(prediccion_knn == setas_test$Venenosas)/nrow(setas_test)
error = 1-accuracy

# Acierto sobre el total de las setas VENENOSAS, sensitivity o recall
sensitivity = sum((prediccion_knn == setas_test$Venenosas) & (setas_test$Venenosas == 1)) / sum(setas_test$Venenosas == 1)
recall = sensitivity

# Acierto sobre el total de las setas COMESTIBLES
specificity =  sum(prediccion_knn == setas_test$Venenosas & setas_test$Venenosas == 0) / sum(setas_test$Venenosas == 0)

# Acierto cuando el predicho es VENENOSAS
precision = sum( (prediccion_knn== setas_test$Venenosas) & (prediccion_knn == 1))/ sum(prediccion_knn == 1)

# Acierto cuando el predicho es COMESTIBLE
npv = sum(prediccion_knn == setas_test$Venenosas & prediccion_knn == 0) / sum(prediccion_knn == 0)

# F1_score
f1score = 2*precision*recall /(precision+recall)


#Tabla de medidas de precisión
c(accuracy = accuracy, error = error, sensitivity = sensitivity, specificity = specificity, precision = precision, npv = npv, f1=f1score)
```
```{r knn cross-validation,echo=TRUE}
prediccion_knn_cv =knn.cv(setas_train[k50$medoid,], k=1, cl=setas_train$Venenosas[k50$medoid])
prediccion_knn_cv

table(prediccion_knn_cv,setas_train$Venenosas[k50$medoid])
k=(dim(setas_train)[1]^(4/(4+dim(setas_train)[2])))*100
```


##  Clustering
##  Arboles de Decisión

##  Bosques Aleatorios
##  Support Vector Machines
##  Redes Neuronales

#  Evaluación


#  Visualización y Presentación de Resultados

#  Puesta en producción
OJO!!! al inicio del estudio, necesitamos reservar parte de la bases de datos para esta etapa. Nos referiremos a esa parte como "los datos guardados en un cajón". Normalmente esta etapa se hace "el último día de clase".

#  Actualización del modelo...
Vuelta a empezar.