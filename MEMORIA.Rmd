---
title: "Memoria del trabajo"
author: "Adrián Rocha De la Casa, Yassin Khalifa Martino y Rocío Fernández Cebrián"
date: "5/10/2021"
output: bookdown::gitbook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#  Introducción

Este conjunto de datos incluye descripciones de muestras hipotéticas basándose en características de hongos de la familia Agaricus y Lepiota.

Para visualizar mejor nuestro análisis necesitamos cargar las siguientes librerías:
```{r librerias,echo=TRUE,warning=FALSE,error=FALSE,message=FALSE}
library(ggplot2)
library(psych)
library(philentropy)
library(kmed)
library(vegan)
library(class)
library(cluster)
library(rpart)
library(rpart.plot)
library(e1071)
library(randomForest)
```

# ¿ Objetivos (del negocio)?

Nuestro objetivo será identificar cada especie como una especie comestible o una especie venenosa/de comestibilidad desconocida.

#  Datos 

Leemos los datos mediante el siguiente comando:
```{r introduccion datos,echo=TRUE}
datos.setas<-read.table("agaricus-lepiota.data",header=FALSE,sep=",")
```

Comprobamos que se han leído correctamente los datos mirando la dimensión de los datos.
```{r dimension,echo=TRUE}
dim(datos.setas)
```

Como ya hemos visto, disponemos de 8124 observaciones de setas de las cuales hemos recogido información sobre 23 características.

Realizamos una exploración básica de los datos para comprobar que tipo de datos disponemos.
```{r tipo de variables, echo=TRUE}
summary(datos.setas)
```
Luego son variables cualitativas y por tanto habrá que tratarlas como factores. Estas variables son:


 NOMBRE VARIABLE | DESCRIPCIÓN
 --------------- | ------------
  Letalidad      | venenosa (p) o comestible(e)
  Forma del sombrebro o píleo | campana (b), cónica (c), convexa (x), plana (f), nudosa (k) o hundida (s)
  Cutícula o superficie del sombrero | fibroso (f), con surcos (g), escamosa (y) o lisa (s)
  Color del sombrero | marrón (n), ante (b), canela (c), gris (g), verde (r), rosa (p), morado (u), rojo (e), blanco (w) o amarillo (y)
  Escamas | verdadero (t) o falso (f)
  Olor | almendra (a), anís (l), creosota (c), pescado (y), asqueroso (f), mohoso (m), ninguno (n), acre(p) o picante (s)
  Fijación de las láminas | adjunto (a), descentente (d), libre (f) o entallado (n)
  Espacio entre láminas | cerca (c), atestado (w) o distante (d)
  Tamaño de las láminas | ancho (b) o estrecho (n)
  Color de las láminas | negro (k), marrón (n), ante (b), chocolate (h), gris (g), verde (r), naranja (o), rosa (p), morado (u), rojo (e), blanco (w) o amarillo (y)
  Forma del tallo | agrandado (e) o afilado (t)
  Tallo-raíz | bulboso (b), club (c), copa (u), igual (e), rizomorfos (z), enraizado (r) o faltante (?)
  Superficie del tallo por encima del anillo | fibroso (f), escamoso (y), sedoso (k) o liso (s)
  Superficie del tallo por debajo del anillo | fibroso (f), escamoso (y), sedoso (k) o liso (s)
  Color del tallo por encima del anillo | marrón (n), ante (b), canela (c), gris (g), naranja (o), rosa (p), rojo (e), blanco (w) o amarillo (y)
  Color del tallo por debajo del anillo | marrón (n), ante (b), canela (c), gris (g), naranja (o), rosa (p), rojo (e), blanco (w) o amarillo (y)
  Tipo de volva | parcial (p) o universal (u)
  Color del volva | marrón (n), naranja (o), blanco (w) o amarillo (y)
  Número de anillos | ninguno (n), uno (o) o dos (t)
  Tipo de anillo | telaraña (c), evanescente (e), abocinado (f), grande (l), ninguno (n), colgante (p), revestimiento (s) o zona (z)
  Color de las esporas | negro (k), marrón (n), ante (b), chocolate (h), verde (r), naranja (o), morado (u), blanco (w) o amarillo (y)
  Población | abundante (a), agrupada (c), numerosa (n), dispersa (s), varias (v) o solitaria (y)
  Habitat | pastos (g), hojas (l), prados (m), caminos (p), urbano (u), desechos (w) o bosques (d)

Vamos a llamar a las variables como la caracteristica que ejemplifican.
```{r nombre de variables}
colnames(datos.setas)=c("Letalidad","Forma_S","Cuticula","Color_S","Escamas","Olor","Fijacion_L","Espacio_L","Tamaño_L","Color_L","Forma_T","Tallo_raiz","Superficie_T1","Superficie_T2","Color_T1","Color_T2","Tipo_V","Color_V","N_anillos","Tipo_anillo","Color_esporas","Poblacion","Habitat")
```


#  Preprocesado de datos.

Para poder tranformar las variables en factor, lo haremos mediante **as.factor()** a todas las variables de los datos.
```{r factores, echo=FALSE}
#VARIABLE RESPUESTA
datos.setas$Letalidad=as.factor(datos.setas$Letalidad)
#VARIABLE 1
datos.setas$Forma_S=as.factor(datos.setas$Forma_S)
#VARIABLE 2
datos.setas$Cuticula=as.factor(datos.setas$Cuticula)
#VARIABLE 3
datos.setas$Color_S=as.factor(datos.setas$Color_S)
#VARIABLE 4
datos.setas$Escamas=as.factor(datos.setas$Escamas)
#VARIABLE 5
datos.setas$Olor=as.factor(datos.setas$Olor)
#VARIABLE 6
datos.setas$Fijacion_L=as.factor(datos.setas$Fijacion_L)
#VARIABLE 7
datos.setas$Espacio_L=as.factor(datos.setas$Espacio_L)
#VARIABLE 8
datos.setas$Tamaño_L=as.factor(datos.setas$Tamaño_L)
#VARIABLE 9
datos.setas$Color_L=as.factor(datos.setas$Color_L)
#VARIABLE 10
datos.setas$Forma_T=as.factor(datos.setas$Forma_T)
#VARIABLE 11
datos.setas$Tallo_raiz=as.factor(datos.setas$Tallo_raiz)
#VARIABLE 12
datos.setas$Superficie_T1=as.factor(datos.setas$Superficie_T1)
#VARIABLE 13
datos.setas$Superficie_T2=as.factor(datos.setas$Superficie_T2)
#VARIABLE 14
datos.setas$Color_T1=as.factor(datos.setas$Color_T1)
#VARIABLE 15
datos.setas$Color_T2=as.factor(datos.setas$Color_T2)
#VARIABLE 16
datos.setas$Tipo_V=as.factor(datos.setas$Tipo_V)
#VARIABLE 17
datos.setas$Color_V=as.factor(datos.setas$Color_V)
#VARIABLE 18
datos.setas$N_anillos=as.factor(datos.setas$N_anillos)
#VARIABLE 19
datos.setas$Tipo_anillo=as.factor(datos.setas$Tipo_anillo)
#VARIABLE 20
datos.setas$Color_esporas=as.factor(datos.setas$Color_esporas)
#VARIABLE 21
datos.setas$Poblacion=as.factor(datos.setas$Poblacion)
#VARIABLE 22
datos.setas$Habitat=as.factor(datos.setas$Habitat)
```

Ahora podemos ver mejor como son nuestros datos.
```{r resumen datos,echo=TRUE}
summary(datos.setas)
```
Una de las variables, **Tipo_v** (tipo de volva) con dos niveles distintos, parcial (p) y universal (u), podríamos eliminarla de nuestros datos pues todo la frecuencia solo está en uno de los niveles, luego no aporta información alguna para determinar si es venenosa o comestible.

```{r eliminar variable,echo=TRUE}
datos.setas=datos.setas[,-17]
```

Además, la variable **Fijacion_L** tendría solo dos niveles pues en el nivel descendente y entallado no aparecen en los datos y la variable **Espacio_L** también tiene dos niveles pues el nivel distante tampoco aparece, por ello las codificamos mediante unas variable binomiales.

Codificamos el resto de las variables originales de forma que obtendremos también nuevas variables binomiales.
```{r codificación,echo=FALSE}
#Variable respuesta: venenosa-1 comestible-0
setas=data.frame(matrix(ncol=1))
colnames(setas)=c("Venenosas")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,1]=="e"){
    setas=rbind(setas,c(0))
  }
  if(datos.setas[i,1]=="p"){
    setas=rbind(setas,c(1))
  }
}

#Variable 1: forma del sombrero
sombrero=matrix(ncol=6)
colnames(sombrero)=c("Campana","Cónica","Convexa","Plana","Nudosa","Hundida")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,2]=="b"){
    sombrero=rbind(sombrero,c(1,0,0,0,0,0))
  }
  if(datos.setas[i,2]=="c"){
    sombrero=rbind(sombrero,c(0,1,0,0,0,0))
  }
  if(datos.setas[i,2]=="x"){
    sombrero=rbind(sombrero,c(0,0,1,0,0,0))
  }
  if(datos.setas[i,2]=="f"){
    sombrero=rbind(sombrero,c(0,0,0,1,0,0))
  }
  if(datos.setas[i,2]=="k"){
    sombrero=rbind(sombrero,c(0,0,0,0,1,0))
  }
  if(datos.setas[i,2]=="s"){
    sombrero=rbind(sombrero,c(0,0,0,0,0,1))
  }
}
setas=cbind(setas,sombrero)

#Variable 2: superficie del sombrero
superficie=matrix(ncol=4)
colnames(superficie)=c("Fibroso","Surcos","Escamoso","Liso")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,3]=="f"){
    superficie=rbind(superficie,c(1,0,0,0))
  }
  if(datos.setas[i,3]=="g"){
    superficie=rbind(superficie,c(0,1,0,0))
  }
  if(datos.setas[i,3]=="y"){
    superficie=rbind(superficie,c(0,0,1,0))
  }
  if(datos.setas[i,3]=="s"){
    superficie=rbind(superficie,c(0,0,0,1))
  }
}
setas=cbind(setas,superficie)

#Variable 3: color del sombrero
color_sombrero=matrix(ncol=10)
colnames(color_sombrero)=c("S_Marrón","S_Ante","S_Canela","S_Gris","S_Verde","S_Rosa","S_Morado","S_Rojo","S_Blanco","S_Amarillo")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,4]=="n"){
    color_sombrero=rbind(color_sombrero,c(1,0,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,4]=="b"){
    color_sombrero=rbind(color_sombrero,c(0,1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,4]=="c"){
    color_sombrero=rbind(color_sombrero,c(0,0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,4]=="g"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,4]=="r"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,4]=="p"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,4]=="u"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,4]=="e"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,4]=="w"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,4]=="y"){
    color_sombrero=rbind(color_sombrero,c(0,0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,color_sombrero)

#Variable 4: Escamas (true-1 false-0) prueba
escamas_S=matrix(ncol=1)
colnames(escamas_S)=c("Escamas")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,5]=="f"){
    escamas_S=rbind(escamas_S,c(0))
  }
  if(datos.setas[i,5]=="t"){
    escamas_S=rbind(escamas_S,c(1))
  }
}
setas=cbind(setas,escamas_S)

#Variable 5: olor
olor=matrix(ncol=9)
colnames(olor)=c("O_almendra","O_anís","O_creosota","O_pescado","O_asqueroso","O_mohoso","O_ninguno","O_acre","O_picante")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,6]=="a"){
    olor=rbind(olor,c(1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,6]=="l"){
    olor=rbind(olor,c(0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,6]=="c"){
    olor=rbind(olor,c(0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,6]=="y"){
    olor=rbind(olor,c(0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,6]=="f"){
    olor=rbind(olor,c(0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,6]=="m"){
    olor=rbind(olor,c(0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,6]=="n"){
    olor=rbind(olor,c(0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,6]=="p"){
    olor=rbind(olor,c(0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,6]=="s"){
    olor=rbind(olor,c(0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,olor)

#Varibale 6: fijación de láminas (adjunto-1 libre-0)
fijacion_laminas=matrix(ncol=1)
colnames(fijacion_laminas)=c("Adjunto/Libre")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,7]=="a"){
    fijacion_laminas=rbind(fijacion_laminas,c(1))
  }
  if(datos.setas[i,7]=="f"){
    fijacion_laminas=rbind(fijacion_laminas,c(0))
  }
}
setas=cbind(setas,fijacion_laminas)

#Variable 7: espacio entre láminas (cerca-1 atestado-0)
espacio_laminas=matrix(ncol=1)
colnames(espacio_laminas)=c("Cerca/Atestado")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,8]=="c"){
    espacio_laminas=rbind(espacio_laminas,c(1))
  }
  if(datos.setas[i,8]=="w"){
    espacio_laminas=rbind(espacio_laminas,c(0))
  }
}
setas=cbind(setas,espacio_laminas)

#Variable 8: tamaño de láminas (ancho-1 estrecho-0)
tamaño_laminas=matrix(ncol=1)
colnames(tamaño_laminas)=c("Ancho/Estrecho")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,9]=="b"){
    tamaño_laminas=rbind(tamaño_laminas,c(1))
  }
  if(datos.setas[i,9]=="n"){
    tamaño_laminas=rbind(tamaño_laminas,c(0))
  }
}
setas=cbind(setas,tamaño_laminas)

#Variable 9: color de láminas
color_laminas=matrix(ncol=12)
colnames(color_laminas)=c("L_Negro","L_Marrón","L_Canela","L_Chocolate","L_Gris","L_Verde","L_Naranja","L_Rosa","L_Morado","L_Rojo","L_Blanco","L_Amarillo")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,10]=="k"){
    color_laminas=rbind(color_laminas,c(1,0,0,0,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="n"){
    color_laminas=rbind(color_laminas,c(0,1,0,0,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="b"){
    color_laminas=rbind(color_laminas,c(0,0,1,0,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="h"){
    color_laminas=rbind(color_laminas,c(0,0,0,1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="g"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="r"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="o"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,10]=="p"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,10]=="u"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,10]=="e"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,10]=="w"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,10]=="y"){
    color_laminas=rbind(color_laminas,c(0,0,0,0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,color_laminas)

#Variable 10: forma del tallo (agrandado-1 afilado-0)
forma_tallo=matrix(ncol=1)
colnames(forma_tallo)=c("Agrandado/Afilado")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,11]=="e"){
    forma_tallo=rbind(forma_tallo,c(1))
  }
  if(datos.setas[i,11]=="t"){
    forma_tallo=rbind(forma_tallo,c(0))
  }
}
setas=cbind(setas,forma_tallo)

#Variable 11: tallo-raíz
tallo_r=matrix(ncol=7)
colnames(tallo_r)=c("TR_bulboso","TR_club","TR_copa","TR_igual","TR_rizomorfos","TR_enraizado","TR_faltante")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,12]=="b"){
    tallo_r=rbind(tallo_r,c(1,0,0,0,0,0,0))
  }
  if(datos.setas[i,12]=="c"){
    tallo_r=rbind(tallo_r,c(0,1,0,0,0,0,0))
  }
  if(datos.setas[i,12]=="u"){
    tallo_r=rbind(tallo_r,c(0,0,1,0,0,0,0))
  }
  if(datos.setas[i,12]=="e"){
    tallo_r=rbind(tallo_r,c(0,0,0,1,0,0,0))
  }
  if(datos.setas[i,12]=="z"){
    tallo_r=rbind(tallo_r,c(0,0,0,0,1,0,0))
  }
  if(datos.setas[i,12]=="r"){
    tallo_r=rbind(tallo_r,c(0,0,0,0,0,1,0))
  }
  if(datos.setas[i,12]=="?"){
    tallo_r=rbind(tallo_r,c(0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,tallo_r)

#Variable 12: superficie del tallo por encima del anillo
superficiet1=matrix(ncol=4)
colnames(superficiet1)=c("ST1_Fibroso","ST1_Escamoso","ST1_Sedoso","ST1_Liso")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,13]=="f"){
    superficiet1=rbind(superficiet1,c(1,0,0,0))
  }
  if(datos.setas[i,13]=="y"){
    superficiet1=rbind(superficiet1,c(0,1,0,0))
  }
  if(datos.setas[i,13]=="k"){
    superficiet1=rbind(superficiet1,c(0,0,1,0))
  }
  if(datos.setas[i,13]=="s"){
    superficiet1=rbind(superficiet1,c(0,0,0,1))
  }
}
setas=cbind(setas,superficiet1)

#Variable 13: superficie del tallo por debajo del anillo
superficiet2=matrix(ncol=4)
colnames(superficiet2)=c("ST2_Fibroso","ST2_Escamoso","ST2_Sedoso","ST2_Liso")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,14]=="f"){
    superficiet2=rbind(superficiet2,c(1,0,0,0))
  }
  if(datos.setas[i,14]=="y"){
    superficiet2=rbind(superficiet2,c(0,1,0,0))
  }
  if(datos.setas[i,14]=="k"){
    superficiet2=rbind(superficiet2,c(0,0,1,0))
  }
  if(datos.setas[i,14]=="s"){
    superficiet2=rbind(superficiet2,c(0,0,0,1))
  }
}
setas=cbind(setas,superficiet2)

#Variable 14: color del tallo por encima del anillo
color.t1=matrix(ncol=9)
colnames(color.t1)=c("CT1_marron","CT1_ante","CT1_canela","CT1_gris","CT1_naranja","CT1_rosa","CT1_rojo","CT1_blanco","CT1_amarillo")
for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,15]=="n"){
    color.t1=rbind(color.t1,c(1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,15]=="b"){
    color.t1=rbind(color.t1,c(0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,15]=="c"){
    color.t1=rbind(color.t1,c(0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,15]=="g"){
    color.t1=rbind(color.t1,c(0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,15]=="o"){
    color.t1=rbind(color.t1,c(0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,15]=="p"){
    color.t1=rbind(color.t1,c(0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,15]=="e"){
    color.t1=rbind(color.t1,c(0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,15]=="w"){
    color.t1=rbind(color.t1,c(0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,15]=="y"){
    color.t1=rbind(color.t1,c(0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,color.t1)
  


#Variable 15: color del tallo por debajo del anillo
color.t2=matrix(ncol=9)
colnames(color.t2)=c("CT2_marron","CT2_ante","CT2_canela","CT2_gris","CT2_naranja","CT2_rosa","CT2_rojo","CT2_blanco","CT2_amarillo")
for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,16]=="n"){
    color.t2=rbind(color.t2,c(1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,16]=="b"){
    color.t2=rbind(color.t2,c(0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,16]=="c"){
    color.t2=rbind(color.t2,c(0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,16]=="g"){
    color.t2=rbind(color.t2,c(0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,16]=="o"){
    color.t2=rbind(color.t2,c(0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,16]=="p"){
    color.t2=rbind(color.t2,c(0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,16]=="e"){
    color.t2=rbind(color.t2,c(0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,16]=="w"){
    color.t2=rbind(color.t2,c(0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,16]=="y"){
    color.t2=rbind(color.t2,c(0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,color.t2)

#Variable 16: color de la volva
color_volva=matrix(ncol=4)
colnames(color_volva)=c("V_Marrón","V_Naranja","V_Blanco","V_Amarillo")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,17]=="n"){
    color_volva=rbind(color_volva,c(1,0,0,0))
  }
  if(datos.setas[i,17]=="o"){
    color_volva=rbind(color_volva,c(0,1,0,0))
  }
  if(datos.setas[i,17]=="w"){
    color_volva=rbind(color_volva,c(0,0,1,0))
  }
  if(datos.setas[i,17]=="y"){
    color_volva=rbind(color_volva,c(0,0,0,1))
  }
}
setas=cbind(setas,color_volva)

#Variable 17: número de anillos
nanillos=matrix(ncol=3)
colnames(nanillos)=c("NA_0","NA_1","NA_2")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,18]=="n"){
    nanillos=rbind(nanillos,c(1,0,0))
  }
  if(datos.setas[i,18]=="o"){
    nanillos=rbind(nanillos,c(0,1,0))
  }
  if(datos.setas[i,18]=="t"){
    nanillos=rbind(nanillos,c(0,0,1))
  }
}
setas=cbind(setas,nanillos)

#Variable 18: tipo de anillo
tanillo=matrix(ncol=8)
colnames(tanillo)=c("TA_Telaraña","TA_Evanescente","TA_Abocinado","TA_Grande","TA_Ninguno","TA_Colgante","TA_Revestimiento","TA_Zona")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,19]=="c"){
    tanillo=rbind(tanillo,c(1,0,0,0,0,0,0))
  }
  if(datos.setas[i,19]=="e"){
    tanillo=rbind(tanillo,c(0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,19]=="f"){
    tanillo=rbind(tanillo,c(0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,19]=="l"){
    tanillo=rbind(tanillo,c(0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,19]=="n"){
    tanillo=rbind(tanillo,c(0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,19]=="p"){
    tanillo=rbind(tanillo,c(0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,19]=="s"){
    tanillo=rbind(tanillo,c(0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,19]=="z"){
    tanillo=rbind(tanillo,c(0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,tanillo)

#Variable 19: color de las esporas
color.e=matrix(ncol=9)
colnames(color.e)=c("CE_negro","CE_marron","CE_ante","CE_chocolate","CE_verde","CE_naranja","CE_morado","CE_blanco","CE_amarillo")
for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,20]=="k"){
    color.e=rbind(color.e,c(1,0,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,20]=="n"){
    color.e=rbind(color.e,c(0,1,0,0,0,0,0,0,0))
  }
  if(datos.setas[i,20]=="b"){
    color.e=rbind(color.e,c(0,0,1,0,0,0,0,0,0))
  }
  if(datos.setas[i,20]=="h"){
    color.e=rbind(color.e,c(0,0,0,1,0,0,0,0,0))
  }
  if(datos.setas[i,20]=="r"){
    color.e=rbind(color.e,c(0,0,0,0,1,0,0,0,0))
  }
  if(datos.setas[i,20]=="o"){
    color.e=rbind(color.e,c(0,0,0,0,0,1,0,0,0))
  }
  if(datos.setas[i,20]=="u"){
    color.e=rbind(color.e,c(0,0,0,0,0,0,1,0,0))
  }
  if(datos.setas[i,20]=="w"){
    color.e=rbind(color.e,c(0,0,0,0,0,0,0,1,0))
  }
  if(datos.setas[i,20]=="y"){
    color.e=rbind(color.e,c(0,0,0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,color.e)

#Variable 20: población
poblation=matrix(ncol=6)
colnames(poblation)=c("Abundante", "Agrupada", "Numerosa", "Dispersa", "Varias", "Solitaria")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,21]=="a"){
    poblation=rbind(poblation,c(1,0,0,0,0,0))
  }
  if(datos.setas[i,21]=="c"){
    poblation=rbind(poblation,c(0,1,0,0,0,0))
  }
  if(datos.setas[i,21]=="n"){
    poblation=rbind(poblation,c(0,0,1,0,0,0))
  }
  if(datos.setas[i,21]=="s"){
    poblation=rbind(poblation,c(0,0,0,1,0,0))
  }
  if(datos.setas[i,21]=="v"){
    poblation=rbind(poblation,c(0,0,0,0,1,0))
  }
  if(datos.setas[i,21]=="y"){
    poblation=rbind(poblation,c(0,0,0,0,0,1))
  }
}
setas=cbind(setas,poblation)

#Variable 21: habitat
habita=matrix(ncol=7)
colnames(habita)=c("Bosques", "Pastos", "Hojas", "Prados", "Caminos", "Urbano", "Desechos")

for(i in 1:dim(datos.setas)[1]){
  if(datos.setas[i,22]=="d"){
    habita=rbind(habita,c(1,0,0,0,0,0,0))
  }
  if(datos.setas[i,22]=="g"){
    habita=rbind(habita,c(0,1,0,0,0,0,0))
  }
  if(datos.setas[i,22]=="l"){
    habita=rbind(habita,c(0,0,1,0,0,0,0))
  }
  if(datos.setas[i,22]=="m"){
    habita=rbind(habita,c(0,0,0,1,0,0,0))
  }
  if(datos.setas[i,22]=="p"){
    habita=rbind(habita,c(0,0,0,0,1,0,0))
  }
  if(datos.setas[i,22]=="u"){
    habita=rbind(habita,c(0,0,0,0,0,1,0))
  }
  if(datos.setas[i,22]=="w"){
    habita=rbind(habita,c(0,0,0,0,0,0,1))
  }
}
setas=cbind(setas,habita)

setas=setas[-1,]
rownames(setas)=as.character(seq(1:dim(datos.setas)[1]))
```

```{r datos codificados,echo=TRUE}
#6 primeras observaciones de los datos ya codificados
head(setas)

#Dimensión
dim(setas)

```

##  Particiones.

```{r particiones}
n_totales=dim(datos.setas)[1]
n_train=floor(n_totales*0.6) # el 60% de los datos los utilizamos para entrenar los modelos
n_test=floor(n_totales*0.2) # el 20% para test
n_validacion=n_totales-n_train-n_test

set.seed(34735)

indices_totales=seq(1:n_totales)
indices_train=sort(sample(indices_totales,n_train))
indices_test=sort(sample(indices_totales[-indices_train],n_test))
indices_validacion=indices_totales[-c(indices_train,indices_test)]


setas_train=setas[indices_train,]
setas_test=setas[indices_test,]
setas_validacion=setas[indices_validacion,]

```


##  EDA. Exploratory Data Analysis.

### Letalidad:
La variable **letalidad** tiene dos niveles distintos, venenosa (p) o comestible (e), la frecuencia relativa correspondiente a nuestros datos es:
```{r proporcion, echo=TRUE}
#Tabla:
table(setas_train$Venenosas)
#Tabla de frecuencias:
prop.table(table(setas_train$Venenosas))
#Gráfico
barplot(table(setas_train$Venenosas),main="Letalidad",ylab="Número de setas",col=c("blue","magenta"),names.arg=c("Comestible","Venenosa"))
```



##  Correlación entre las variables.

Vamos a comprobar si existe alguna correlación entre las distintas variables. 

### Forma del sombrero (Forma_S)

```{r forma del sombrero,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~forma del sombrero
table(datos.setas$Letalidad,datos.setas$Forma_S)
#Gráfico letalidad~forma del sombrero
barplot(table(datos.setas$Letalidad,datos.setas$Forma_S),main="Letalidad vs Forma del sombrero",xlab="Forma",ylab="Número de setas",names.arg=c("Campana", "Cónica", "Plana", "Nudosa", "Hundida", "Convexa"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Forma_S))
```


### Cutícula

```{r cuticula,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~cuticula
table(datos.setas$Letalidad,datos.setas$Cuticula)
#Gráfico letalidad~cuticula
barplot(table(datos.setas$Letalidad,datos.setas$Cuticula),main="Letalidad vs Cuticula",xlab="Cuticula",ylab="Número de setas",names.arg=c("Fibroso", "Con surcos", "Lisa", "Escamosa"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Cuticula))
```


### Color del sombrero (Color_S)

```{r color del sombrero,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color del sombrero
table(datos.setas$Letalidad,datos.setas$Color_S)
#Gráfico letalidad~color del sombrero
barplot(table(datos.setas$Letalidad,datos.setas$Color_S),main="Letalidad vs Color del sombrero",xlab="Color",ylab="Número de setas",names.arg=c("Ante", "Canela", "Rojo", "Gris","Marrón","Rosa","Verde","Morado","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_S))
```


### Escamas

```{r escamas,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~escamas
table(datos.setas$Letalidad,datos.setas$Escamas)
#Gráfico letalidad~escamas
barplot(table(datos.setas$Letalidad,datos.setas$Escamas),main="Letalidad vs Escamas",xlab="Escamas",ylab="Número de setas",names.arg=c("Sin escamas", "Con escamas"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Escamas))
```


### Olor

```{r olor setas,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~olor
table(datos.setas$Letalidad,datos.setas$Olor)
#Gráfico letalidad~olor
barplot(table(datos.setas$Letalidad,datos.setas$Olor),main="Letalidad vs Olor",xlab="Olor",ylab="Número de setas",names.arg=c("Almendra", "Creosota","Asqueroso","Anís","Mohoso","Ninguno","Acre","Picante","Pescado"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Olor))
```
Podemos observar que la variable **olor** se distribuye entre los distintos tipos de olor de forma binaria, es decir, todas las setas que presentan un olor del tipo *creosota, asqueroso, mohoso, acre, picante o pesacado* son venenosas mientras que si presentan un olor del tipo *almendar, anís * son comestibles, mientras que si es *ninguno* el olor tienes una proporción de 97% de que sea comestible. 
```{r proporcion olor,echo=TRUE}
#Proporción según olor sea ninguno
prop.table(table(datos.setas$Letalidad,datos.setas$Olor)[,6])
```
Entonces modríamos cambiar la codificación hecha anteriormente y tener solo una variable codificada de forma binaria de tal forma que para los olores que producen que la seta sea venenosa darles el valor 1 y para los que no, darles el valor 0.


### Fijación de las láminas (Fijacion_L)

```{r fijacion,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~fijación de las láminas
table(datos.setas$Letalidad,datos.setas$Fijacion_L)
#Gráfico letalidad~fijación de las láminas
barplot(table(datos.setas$Letalidad,datos.setas$Fijacion_L),main="Letalidad vs Fijación de las láminas",xlab="Fijación",ylab="Número de setas",names.arg=c("Adjunto", "Libre"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Fijacion_L))
```
Podemos ver que la proporción de que la seta sea venenosa o comestible según la fijación de las láminas en el caso de que estén libre es casi del 50% mientras que si están adjuntas la proporción cambia a un 94% frente a un 6%, comestible o venenosa, respectivamente.
```{r proporcion fijacion,echo=TRUE}
#Proporción según fijacion sea adjunto
prop.table(table(datos.setas$Letalidad,datos.setas$Fijacion_L)[,1])*100

#Proporción según fijacion sea libre
prop.table(table(datos.setas$Letalidad,datos.setas$Fijacion_L)[,2])*100
```


### Espacio entre láminas (Espacio_L)

```{r espacio,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~espacio entre láminas
table(datos.setas$Letalidad,datos.setas$Espacio_L)
#Gráfico letalidad~espacio entre láminas
barplot(table(datos.setas$Letalidad,datos.setas$Espacio_L),main="Letalidad vs Espacio entre láminas",xlab="Espacio",ylab="Número de setas",names.arg=c("Cerca", "Atestado"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Espacio_L))
```
Podemos ver que ocurre algo parecido que en la variable **fijacion_L**, la proporción de que la seta sea venenosa o comestible según el espacio entre las láminas en el caso de que estén cerca es casi del 50% mientras que si están atestado la proporción cambia a un 92% frente a un 8%, comestible o venenosa, respectivamente.
```{r proporcion espacio,echo=TRUE}
#Proporción según espacio sea cerca
prop.table(table(datos.setas$Letalidad,datos.setas$Espacio_L)[,1])*100

#Proporción según espacio sea atestado
prop.table(table(datos.setas$Letalidad,datos.setas$Espacio_L)[,2])*100
```


### Tamaño de las láminas (Tamaño_L)

```{r tamaño,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~tamaño de las láminas
table(datos.setas$Letalidad,datos.setas$Tamaño_L)
#Gráfico letalidad~tamaño de las láminas
barplot(table(datos.setas$Letalidad,datos.setas$Tamaño_L),main="Letalidad vs Tamaño de las láminas",xlab="Tamaño",ylab="Número de setas",names.arg=c("Ancho", "Estrecho"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Tamaño_L))
```
Podemos ver que la proporción de que la seta sea venenosa o comestible según el tamaño de las láminas en el caso de que sea ancha es del 30% frente a 70%, respectivamente, mientras que si es estrecho la proporción cambia a un 11.5% frente a un 88.5%, respectivamente.
```{r proporcion tamaño,echo=TRUE}
#Proporción según tamaño sea ancho
prop.table(table(datos.setas$Letalidad,datos.setas$Tamaño_L)[,1])*100

#Proporción según tamaño sea estrecho
prop.table(table(datos.setas$Letalidad,datos.setas$Tamaño_L)[,2])*100
```


### Color de las láminas (Color_L)

```{r color laminas,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color de las láminas
table(datos.setas$Letalidad,datos.setas$Color_L)
#Gráfico letalidad~color de las láminas
barplot(table(datos.setas$Letalidad,datos.setas$Color_L),main="Letalidad vs Color de las láminas",xlab="Color",ylab="Número de setas",names.arg=c("Ante", "Rojo","Gris","Chocolate","Negro","Marrón","Naranja","Rosa","Verde","Morado","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_L))
```


### Forma del tallo (Forma_T)

```{r forma tallo,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~forma del tallo
table(datos.setas$Letalidad,datos.setas$Forma_T)
#Gráfico letalidad~forma del tallo
barplot(table(datos.setas$Letalidad,datos.setas$Forma_T),main="Letalidad vs Forma del tallo",xlab="Tallo",ylab="Número de setas",names.arg=c("Agrandado", "Afilado"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Forma_T))
```
Podemos ver que la proporción de que la seta sea venenosa o comestible según el forma del tallo es casi del 50% en ambos formas del tallo
```{r proporcion forma,echo=TRUE}
#Proporción según forma sea agrandado
prop.table(table(datos.setas$Letalidad,datos.setas$Forma_T)[,1])*100

#Proporción según forma sea afilado
prop.table(table(datos.setas$Letalidad,datos.setas$Forma_T)[,2])*100
```


### Tallo-Raíz (Tallo_raiz)

```{r tallo raiz,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~tallo-raiz
table(datos.setas$Letalidad,datos.setas$Tallo_raiz)
#Gráfico letalidad~tallo-raiz
barplot(table(datos.setas$Letalidad,datos.setas$Tallo_raiz),main="Letalidad vs Tallo-Raiz",xlab="Tallo-Raiz",ylab="Número de setas",names.arg=c("Faltante", "Bulboso","Club","Igual","Enraizado"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Tallo_raiz))
```


### Superficie del tallo por encima del anillo (Superficie_T1)

```{r superficie t1,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~supercifie del tallo por encima del anillo
table(datos.setas$Letalidad,datos.setas$Superficie_T1)
#Gráfico letalidad~superficie del tallo por encima del anillo
barplot(table(datos.setas$Letalidad,datos.setas$Superficie_T1),main="Letalidad vs Tallo por encima del anillo",xlab="Superficie",ylab="Número de setas",names.arg=c("Fibroso", "Sedoso","Liso","Escamoso"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Superficie_T1))
```


### Superficie del tallo por debajo del anillo (Superficie_T2)

```{r superficie t2,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~supercifie del tallo por debajo del anillo
table(datos.setas$Letalidad,datos.setas$Superficie_T2)
#Gráfico letalidad~superficie del tallo por debajo del anillo
barplot(table(datos.setas$Letalidad,datos.setas$Superficie_T2),main="Letalidad vs Tallo por debajo del anillo",xlab="Superficie",ylab="Número de setas",names.arg=c("Fibroso", "Sedoso","Liso","Escamoso"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Superficie_T2))
```


### Color del tallo por encima del anillo (Color_T1)

```{r color t1,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color del tallo por encima del anillo
table(datos.setas$Letalidad,datos.setas$Color_T1)
#Gráfico letalidad~color del tallo por encima del anillo
barplot(table(datos.setas$Letalidad,datos.setas$Color_T1),main="Letalidad vs Tallo por encima del anillos",xlab="Color",ylab="Número de setas",names.arg=c("Ante", "Canela","Rojo","Gris","Marrón","Naranja","Rosa","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_T1))
```


### Color del tallo por debajo del anillo (Color_T2)

```{r color t2,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color del tallo por debajo del anillo
table(datos.setas$Letalidad,datos.setas$Color_T2)
#Gráfico letalidad~color del tallo por debajo del anillo
barplot(table(datos.setas$Letalidad,datos.setas$Color_T2),main="Letalidad vs Tallo por debajo del anillos",xlab="Color",ylab="Número de setas",names.arg=c("Ante", "Canela","Rojo","Gris","Marrón","Naranja","Rosa","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_T2))
```


### Color del volva (Color_V)

```{r color volva,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color del volva
table(datos.setas$Letalidad,datos.setas$Color_V)
#Gráfico letalidad~color del volva
barplot(table(datos.setas$Letalidad,datos.setas$Color_V),main="Letalidad vs Volva",xlab="Color",ylab="Número de setas",names.arg=c("Marrón", "Naranja","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_V))
```


### Número de anillos (N_anillos)

```{r numero anillos,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~numero de anillos
table(datos.setas$Letalidad,datos.setas$N_anillos)
#Gráfico letalidad~numero de anillos
barplot(table(datos.setas$Letalidad,datos.setas$N_anillos),main="Letalidad vs Anillos",xlab="Número",ylab="Número de setas",names.arg=c("Ninguno", "Uno","Dos"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$N_anillos))
```


### Tipo de anillo (Tipo_anillo)

```{r tipo anillos,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~tipo de anillo
table(datos.setas$Letalidad,datos.setas$Tipo_anillo)
#Gráfico letalidad~tipo de anillo
barplot(table(datos.setas$Letalidad,datos.setas$Tipo_anillo),main="Letalidad vs Anillo",xlab="Tipo",ylab="Número de setas",names.arg=c("Evanescente", "Abocinado","Grande","Ninguno","Colgante"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Tipo_anillo))
```


### Color de las esporas

```{r color esporas,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~color de las esporas
table(datos.setas$Letalidad,datos.setas$Color_esporas)
#Gráfico letalidad~color de las esporas
barplot(table(datos.setas$Letalidad,datos.setas$Color_esporas),main="Letalidad vs Esporas",xlab="Color",ylab="Número de setas",names.arg=c("Ante", "Chocolate","Negro","Marrón","Naranja","Verde","Morado","Blanco","Amarillo"),col=c("blue","magenta"))

#Test de independencia:
chisq.test(table(datos.setas$Letalidad,datos.setas$Color_esporas))
```
Podemos observar que aquellas setas que tengan el color de las esporas *ante, naranja, morado o amarillo* son comestibles.


### Población

```{r poblacion,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~poblacion
table(datos.setas$Letalidad,datos.setas$Poblacion)
#Gráfico letalidad~poblacion
barplot(table(datos.setas$Letalidad,datos.setas$Poblacion),main="Letalidad",xlab="Poblacion",ylab="Número de setas",names.arg=c("abundante", "agrupada", "numerosa", "dispersa", "varias", "solitaria"),col=c("blue","magenta"))
#legend(x = "topright", legend = c("Comestible","Venenosa"), fill = c("blue", "magenta"))
```


### Habitat

```{r habitat,echo=TRUE,warning=FALSE}
#Tabla de frecuencias letalidad~habitat
table(datos.setas$Letalidad,datos.setas$Habitat)
#Gráfico letalidad~habitat
barplot(table(datos.setas$Letalidad,datos.setas$Habitat),main="Letalidad",xlab="Habitat",ylab="Número de setas",names.arg=c("bosques", "pastos", "hojas", "prados", "caminos", "urbano", "desechos"),col=c("blue","magenta"))
#legend(x = "topright", legend = c("Comestible","Venenosa"), fill = c("blue", "magenta"))
```

## Componentes principales

### Proceso previo
Dada la naturaleza de nuestros datos, no nos es posible usar las distancias euclideas como medida para comparar como de cerca están dos observaciones, por ellos debemos usar otras medidas de similitud. Para ello, usamos la siguiente tabla de contingencia:

  |1|0
-|-|-
1|a|b
0|c|d

Hacemos un intento de calcular nuestra propia medida de similitud mediante un algoritmo, pero vemos que el proceso es muy largo debido a la dimensión de la matriz de los datos, por ellos buscamos alguna función predeterminada en R que sea capaz de hacerla.
```{r intento medida de similitud dice,eval=FALSE}
#i observacion1, j observacion2, k caracteristica
i=1
n=dim(setas_train)[1]
k=dim(setas_train)[2]
distancia_dice=diag(n)
while(i<n){
  j=i+1
  while(j<=n) {
    #Calculo de similitud
    a=sum(setas_train[i,2:k]*setas_train[j,2:k])
    d=sum((1-setas_train[i,2:k])*(1-setas_train[j,2:k]))
    distancia_dice[i,j]=((2*a)/(a+(k-d)))
    distancia_dice[j,i]=((2*a)/(a+(k-d)))
    j=j+1
  }
  i=i+1
}
```

Encontramos la función *designdist()* que nos permite definir nuestra propia medida de similitud. La cebezara de está función será
$$designdist(datos,metodo,abcd)$$
donde **datos** es nuestra matriz codificada de forma binaria, **metodo** escribiremos la expresión de la medida de similitud que queramos y **abcd=TRUE** usa la tabla de contingencia para datos binarios.

```{r intento medida de similitud dice1,eval=FALSE}
designdist(setas_train[,2:117],"(2*a)/(2*a+b+c)",abcd=TRUE)
```

Finalmente nos decantaremos por la función *distance()* de la librería **_philentropy_**, a la cual debemos introducirle como parámetros la matriz con nuestros datos codificados y el método por el cual queremos calcular la distancia, en nuestro caso, utilizamos *method="dice"*, cuya expresión matemática es exactamente:
$$d = \dfrac{\sum(P_i − Q_i)^2}{(\sum P_i^2 + \sum Q_i^2)}$$
```{r distancias,echo=TRUE,warning=FALSE}
#Distancia Dice
distancia_dice=distance(setas_train[,2:117],method="dice")
```

Una vez calculada nuestra medida de similitud, buscamos encontrar unos puntos que nos sirvan como referentes, para ellos calculamos una cierta cantidad de medoides que los hallaremos trabajando con particiones e intentan minimizar la distancia entre puntos de un grupo y otro punto designado como el centro de ese grupo. A diferencia de *kmeans()*, *fastkmed()* escoge como medoides puntos de los datos y trabaja con una métrica arbitraria de distancias.

```{r medoides,echo=TRUE}
#Cálculo de los medoides: 
k50=fastkmed(distancia_dice,ncluster=50)

#Proporción de los medoides:
table(setas_train$Venenosas[k50$medoid])
```
Podemos ver que de los 50 medoides que hemos calculado, necesitamos 19 para explicar las setas no venenosas mientras que solo 11 para las venenosas. La proporción se mantiene cogiendo un número distinto de medoides, siendo entre un 70%-80% de los medoides setas no venenosas.

Con estos medoides podemos realizar un análisis de componente principales.
```{r pca,echo=TRUE}
distancia_medoides=distancia_dice[k50$medoid,k50$medoid]
#Análisis Componentes principales:
pca.50=prcomp(distancia_medoides)
plot(pca.50)
plot(pca.50$x,col=setas_train$Venenosas[k50$medoid]+1,pch=19)
```
Podemos ver  como la variabilidad de los datos se explica mayoritariamente por la primera componente principal  PC1, aunque nos quedaremos con las dos primeras.

En la otra gráfica, vemos como los medoides que se encuentra con un valor de $PC1<0$ son setas no venenosas, si $PC1>1.5$ las setas son venenosas, mientras que en el intervalo $PC1\in(0,1.5)$ tenemos setas venenosas y no venenosas.

Las dos gráficas siguientes son las mismas que la anterior, pero las realizamos para ver si algunos de los puntos está superpuesto por otro. Esto solo ocurre en un punto.

```{r grafico pca alternativo,echo=TRUE}
#Gráfico:
##Indices de los medoides según toxicidad:
comestible=which(setas_train[k50$medoid,1]==0)
no.comestibles=which(setas_train[k50$medoid,1]==1)

par(mfrow=c(1,2))
plot(pca.50$x)
points(pca.50$x[comestible,1:2],col=1,pch=19)
points(pca.50$x[no.comestibles,1:2],col=2,pch=19)
plot(pca.50$x)
points(pca.50$x[no.comestibles,1:2],col=2,pch=19)
points(pca.50$x[comestible,1:2],col=1,pch=19)
```

Pero trabajar solo con los 50 medoides podemos perder mucha información, por ellos rehacemos todo lo anterior pero ahora aplicaremos el análisis de componentes principales a la distancia de todas las observaciones con los 50 medoides.

```{r medoides a observaciones,echo=TRUE}
#Análsiis de componentes principales
pca.train=prcomp(distancia_dice[,k50$medoid])
plot(pca.train)
plot(pca.train$x,col=setas_train$Venenosas+1,pch=19)

#Gráfico alternativo
comestible=which(setas_train[,1]==0)
no.comestibles=which(setas_train[,1]==1)

par(mfrow=c(1,2))
plot(pca.train$x,type="n")
points(pca.train$x[comestible,1:2],col=1,pch=19)
points(pca.train$x[no.comestibles,1:2],col=2,pch=19)
plot(pca.train$x,type="n")
points(pca.train$x[no.comestibles,1:2],col=2,pch=19)
points(pca.train$x[comestible,1:2],col=1,pch=19)
```

Observamos algo bastante parecido a lo obtenido en el análisis anterior, dos zonas bastante bien diferenciadas y otra zona donde coinciden las stas venenosas y las comestibles. Luego podemos llegar a suponer que el número de cluster necesarios serían 5 como ocurría en el análisis anterior, pero vamos a probar con un número mayor de cluster para intentar clasificar lo mejor posible la nube de puntos de $PC1\in(-1,2)$ y $PC2\in(-1,0.5)$. 



Quizás no sean necesarios 50 medoides para realizar el análisis y podríamos obtener un resultado parecido con una cantidad menor. Por ello, vamos a probar a hacerlo pero con una cantidad más reducida de medoides. Tomamos un valor entre 10 y 20 medoides.

```{r medoides 15,echo=TRUE}
#Cálculo de los medoides: 
k15=fastkmed(distancia_dice,ncluster=15)
#Proporción de los medoides:
table(setas_train$Venenosas[k15$medoid])


#Análsiis de componentes principales
pca.train15=prcomp(distancia_dice[,k15$medoid])
plot(pca.train15)
plot(pca.train15$x,col=setas_train$Venenosas+1,pch=19)

#Gráfico alternativo
comestible=which(setas_train[,1]==0)
no.comestibles=which(setas_train[,1]==1)

par(mfrow=c(1,2))
plot(pca.train15$x)
points(pca.train15$x[comestible,1:2],col=1,pch=19)
points(pca.train15$x[no.comestibles,1:2],col=2,pch=19)
plot(pca.train15$x)
points(pca.train15$x[no.comestibles,1:2],col=2,pch=19)
points(pca.train15$x[comestible,1:2],col=1,pch=19)
```

```{r medoides 10,echo=TRUE}
#Cálculo de los medoides: 
k10=fastkmed(distancia_dice,ncluster=10)
#Proporción de los medoides:
table(setas_train$Venenosas[k10$medoid])


#Análsiis de componentes principales
pca.train10=prcomp(distancia_dice[,k10$medoid])
plot(pca.train10)
plot(pca.train10$x,col=setas_train$Venenosas+1,pch=19)

#Gráfico alternativo
comestible=which(setas_train[,1]==0)
no.comestibles=which(setas_train[,1]==1)

par(mfrow=c(1,2))
plot(pca.train10$x)
points(pca.train10$x[comestible,1:2],col=1,pch=19)
points(pca.train10$x[no.comestibles,1:2],col=2,pch=19)
plot(pca.train10$x)
points(pca.train10$x[no.comestibles,1:2],col=2,pch=19)
points(pca.train10$x[comestible,1:2],col=1,pch=19)
```

```{r medoides 20,echo=TRUE}
#Cálculo de los medoides: 
k20=fastkmed(distancia_dice,ncluster=20)
#Proporción de los medoides:
table(setas_train$Venenosas[k20$medoid])


#Análsiis de componentes principales
pca.train20=prcomp(distancia_dice[,k20$medoid])
plot(pca.train20)
plot(pca.train20$x,col=setas_train$Venenosas+1,pch=19)

#Gráfico alternativo
comestible=which(setas_train[,1]==0)
no.comestibles=which(setas_train[,1]==1)

par(mfrow=c(1,2))
plot(pca.train20$x)
points(pca.train20$x[comestible,1:2],col=1,pch=19)
points(pca.train20$x[no.comestibles,1:2],col=2,pch=19)
plot(pca.train20$x)
points(pca.train20$x[no.comestibles,1:2],col=2,pch=19)
points(pca.train20$x[comestible,1:2],col=1,pch=19)
```

Los resultados son bastantes parecidos cuando cogemos una cantidad de medoides entre 10 y 20. 
A pesar de ellos, nos quedaremos con la distancia de todas las observaciones a los 50 medoides, para tener más información.



##  Transformación de variables

Las variables no necesitan ninguna modificación adicional, pues ya las hemos codificado anteriormente. Lo único que transformamos son nuestro datos. A partir de ahora, los datos serán la distancia de cada seta a los 50 medoides que hemos calculado, esto permite utilizar la distancia euclínea en los algoritmos posteriores.

```{r datos transformados,echo=TRUE}
#Datos train:
setas50_train=distancia_dice[,k50$medoid]

#Datos test:
medoides_setas_test=rbind(setas_train[k50$medoid,],setas_test)
distancia_medoides_test=distance(medoides_setas_test[,2:117],method="dice")
setas50_test=distancia_medoides_test[-c(1:50),c(1:50)]

#Datos validation:
medoides_setas_validacion=rbind(setas_train[k50$medoid,],setas_validacion)
distancia_medoides_validacion=distance(medoides_setas_validacion[,2:117],method="dice")
setas50_validacion=distancia_medoides_validacion[-c(1:50),c(1:50)]
```

##  Imputacion de datos (datos faltantes)

No se requiere de imputación de datos, pues no hay datos faltantes en ninguna de las variables.

#  Modelado


## Análisis Cluster

El análisis cluster es un conjunto de técnicas multivariantes utilizadas para clasificar a un conjunto de individuos en grupos homogéneos.

```{r cluster,echo=TRUE}
#Números de clusters
SSW <- vector(mode = "numeric", length = 15)
n=dim(prcomp(setas50_train)$x)[1]
#Variabilidad de todos los datos, es decir, todos los datos como un único cluster
SSW[1] <- (n - 1) * sum(apply(prcomp(setas50_train)$x,2,var)) 

#Variabilidad de cada modelo, desde 2 clusters hasta 15 clusters
for (i in 2:15) SSW[i] <- sum(kmeans(prcomp(setas50_train)$x,centers=i,nstart=25)$withinss)

#Dibujamos un gráfico con el resultado
plot(1:15, SSW, type="b", xlab="Número de clusters", ylab="Suma de cuadrados de los grupos",pch=19, col="steelblue4")
```

En el gráfico podemos observar que a partir del aplicar 5 clusters a nuestros datos la suma de los cuadrados se reduce en menor medida, por ello realizamos el análisis con ese número de clusters.

```{r analisis cluster 5,echo=TRUE}
#Análisis cluster
clusters.datos=kmeans(prcomp(setas50_train)$x,centers=5,nstart=25)
table(clusters.datos$cluster,setas_train$Venenosas)
```
Podemos ver que un cluster identificar correctamente a las setas venenosas mientras que el resto de cluster las setas están un poco más repartidas, por ejemplo el cluster que reparte las setas de la forma 612-475 es menos especifíco que los cluster que reparten 843-6, 1056-6 y 11-1097.

```{r grafico cluster 5,echo=TRUE}
pca=prcomp(setas50_train)$x

#Gráfico de los cluster
plot(prcomp(setas50_train)$x,main="Clusters",type="n")
for(i in 1:dim(setas50_train)[1]){
  points(pca[i,1],pca[i,2],pch=19,col=clusters.datos$cluster[i]+1)
}
legend("topright",   
       inset = 0.01, 
       legend = c(1:5),
       fil = seq(2,6))


#Gráfico por tipo de setas:
par(mfrow=c(1,2))
plot(prcomp(setas50_train)$x,main="Clusters: setas comestibles",type="n")
for(i in 1:dim(setas50_train)[1]){
  if(setas_train[i,1]==0){
    points(pca[i,1],pca[i,2],pch=19,col=clusters.datos$cluster[i]+1)
  }
}
legend("topright",   
       inset = 0.01, 
       legend = c(1:5),
       fil = seq(2,6))
plot(prcomp(setas50_train)$x,main="Clusters: setas venenosas",type="n")
for(i in 1:dim(setas50_train)[1]){
  if(setas_train[i,1]==1){
    points(pca[i,1],pca[i,2],pch=19,col=clusters.datos$cluster[i]+1)
  }
}
legend("topright",   
       inset = 0.01, 
       legend = c(1:5),
       fil = seq(2,6))
```

En estos gráficos podemos ver lo que hemos comentado antes, tenemos bastante bien clasificados los tipos de setas pero uno de los cluster no clasifica tan bien como los otros, pues las setas están mezcladas, luego habría que estudiar ese para ver como diferenciar las venenosas de las comestibles.


Vamos a realizar otro análisis cluster pero aumentando el número de cluster con la intención de con un número mayor de cluster se clasifiquen mejor las setas.

```{r analisis cluster 8,echo=TRUE}
#Análisis cluster
clusters.datos.train=kmeans(prcomp(setas50_train)$x,centers=8,nstart=25)
table(clusters.datos.train$cluster,setas_train$Venenosas)
```

```{r grafico cluster 8,echo=TRUE}
pca=prcomp(setas50_train)$x

#Gráfico de los cluster
plot(prcomp(setas50_train)$x,main="Clusters",type="n")
for(i in 1:dim(setas50_train)[1]){
  points(pca[i,1],pca[i,2],pch=19,col=clusters.datos.train$cluster[i]+1)
}
legend("topright",   
       inset = 0.01, 
       legend = c(1:8),
       fil = seq(2,9))


#Gráfico por tipo de setas:
par(mfrow=c(1,2))
plot(prcomp(setas50_train)$x,main="Clusters: setas comestibles",type="n")
for(i in 1:dim(setas50_train)[1]){
  if(setas_train[i,1]==0){
    points(pca[i,1],pca[i,2],pch=19,col=clusters.datos.train$cluster[i]+1)
  }
}
legend("topright",   
       inset = 0.01, 
       legend = c(1:8),
       fil = seq(2,9))
plot(prcomp(setas50_train)$x,main="Clusters: setas venenosas",type="n")
for(i in 1:dim(setas50_train)[1]){
  if(setas_train[i,1]==1){
    points(pca[i,1],pca[i,2],pch=19,col=clusters.datos.train$cluster[i]+1)
  }
}
legend("topright",   
       inset = 0.01, 
       legend = c(1:8),
       fil = seq(2,9))
```

Vemos que tras realizar el análisis cluster con 8 grupos, no obtenemos tan claramente la clasificación de setas pero volvemos a tener dos grupos bien diferenciados, que son los que vemos en el gráfico del análisis de componentes principales, el resto están mezclados entre los cluster y habría que analizar cada uno de ellos para poder obtener alguna información más.




##  k-NN

El algoritmo k-NN clasifica cada dato nuevo en el grupo que corresponda, según tenga k vecinos más cerca de un grupo o de otro. Es decir, calcula la distancia del elemento nuevo a cada uno de los existentes, y ordena dichas distancias de menor a mayor para ir seleccionando el grupo al que pertenecer. Este grupo será, por tanto, el de mayor frecuencia con menores distancias.


```{r knn,echo=TRUE}
#Buscamos los vecinos más cercanos
prediccion_knn=knn(setas50_train,setas50_test,cl=setas_train$Venenosas,k=1)
table(prediccion_knn,setas_test$Venenosas)
```

La predicción con el 1-vecino más próximo, es bastante buena, lo podemos ver a simple vista en la tabla. Pero vamos a realizar un análisis con distintas medidas de precisión.

```{r medidas de precision knn,echo=TRUE}
# Exactitud/Error
accuracy = sum(prediccion_knn == setas_test$Venenosas)/nrow(setas_test)
error = 1-accuracy

# Acierto sobre el total de las setas VENENOSAS, sensitivity o recall
sensitivity = sum((prediccion_knn == setas_test$Venenosas) & (setas_test$Venenosas == 1)) / sum(setas_test$Venenosas == 1)
recall = sensitivity

# Acierto sobre el total de las setas COMESTIBLES
specificity =  sum(prediccion_knn == setas_test$Venenosas & setas_test$Venenosas == 0) / sum(setas_test$Venenosas == 0)

# Acierto cuando el predicho es VENENOSAS
precision = sum( (prediccion_knn== setas_test$Venenosas) & (prediccion_knn == 1))/ sum(prediccion_knn == 1)

# Acierto cuando el predicho es COMESTIBLE
npv = sum(prediccion_knn == setas_test$Venenosas & prediccion_knn == 0) / sum(prediccion_knn == 0)

# F1_score
f1score = 2*precision*recall /(precision+recall)

#Tabla de medidas de precisión
c(accuracy = accuracy, error = error, sensitivity = sensitivity, specificity = specificity, precision = precision, npv = npv, f1=f1score)
```

Si usamos el 1 vecino más cercano, podemos ver en sus medidas de precisión que el ajueste es como decíamos, es decir, predice la toxicidad de las setas con un grado de acierto muy alto, solo comete un error del 0.3%.

Pero vamos a probar a calcular todas estas medidas con un número distinto de vecinos más cercano, por si acaso disminuyese ese pequeño error.

```{r knn cross-validation,echo=TRUE}
k=(dim(setas50_train)[1]^(4/(4+dim(setas50_train)[2])))*10

#Matriz de las medidas de precision:
medidas_presicision=matrix(nrow=round(k),ncol=7)
nombres_medidas=c("accuracy", "error", "sensitivity", "specificity", "precision", "npv", "f1score")
colnames(medidas_presicision)=nombres_medidas
for (i in 1:round(k)){
  prediccion_knn=knn(setas_train[k50$medoid,],setas_test,cl=setas_train$Venenosas[k50$medoid],k=i)
  medidas_presicision[i,1] = sum(prediccion_knn == setas_test$Venenosas)/nrow(setas_test)
  medidas_presicision[i,2] = 1-medidas_presicision[i,1]
  medidas_presicision[i,3] = sum((prediccion_knn == setas_test$Venenosas) & (setas_test$Venenosas == 1)) /sum(setas_test$Venenosas == 1)
  medidas_presicision[i,4] =  sum(prediccion_knn == setas_test$Venenosas & setas_test$Venenosas == 0) / sum(setas_test$Venenosas == 0)
  medidas_presicision[i,5] = sum( (prediccion_knn== setas_test$Venenosas) & (prediccion_knn == 1))/ sum(prediccion_knn == 1)
  medidas_presicision[i,6] = sum(prediccion_knn == setas_test$Venenosas & prediccion_knn == 0) / sum(prediccion_knn == 0)
  medidas_presicision[i,7] = 2*medidas_presicision[i,5]*medidas_presicision[i,3] /(medidas_presicision[i,5]+medidas_presicision[i,3])
}
medidas_presicision

#Grafico de las medidas de precision
plot(seq(1,round(k)),medidas_presicision[,1],main="Medidas de precision",type="n",xlab="Número de k vecinos",ylab="",ylim=c(0,1),xlim=c(1,round(k)+2))
for (i in 1:7) {
  points(seq(1,round(k)),medidas_presicision[,i],lwd=2,col=i+1)
  lines(seq(1,round(k)),medidas_presicision[,i],lwd=2,col=i+1)
}
legend("topright",   
       inset = 0.01, 
       legend = c("Ac","Er", "Se","Sp","Pr","NPV","F1"),
       fil = seq(2, round(k)+1))
```

Observamos que para un número de vecinos mayor que 4, las medidas de precisión van empeorando, lo vemos muy claramente en el la medida de error y de sensibilidad, pasa de haber solo un 10% de error a un 13% y de una sensibilidad del casi 80% a un 71%. Luego cualquier número de vecino que eligamos menor de 5, obtendremos unas medidas bastante parecidas. Entonces como dijimos en el caso del vecino más cercano, el grado de acierto al predecir es alto.


##  Arboles de Decisión

Un árbol de decisión es un modelo de predicción utilizado en diversos ámbitos. Dado un conjunto de datos se fabrican diagramas de construcciones lógicas, muy similares a los sistemas de predicción basados en reglas, que sirven para representar y categorizar una serie de condiciones que ocurren de forma sucesiva, para la resolución de un problema.

```{r arbol de decision,echo=TRUE}
setas50_train.respuesta=data.frame(cbind(setas_train[,1],setas50_train))
names(setas50_train.respuesta)[1]="Venenosas"
arbol=rpart(as.factor(setas50_train.respuesta$Venenosas)~., data=setas50_train.respuesta,method="class")
summary(arbol)

#Árbol de decisión:
rpart.plot(arbol)

#Tabla comparativa:
setas50_test.data=as.data.frame(setas50_test)
colnames(setas50_test.data)=colnames(setas50_train.respuesta)[2:51]
prediccion.arbol=round(predict(arbol,setas50_test.data)[,2])
table(prediccion.arbol,setas_test[,1])
```

El gráfico resultante no es interpretable pues nuestro datos están basado en la distancia de las observaciones a los medoides que hemos calculado anteriormente, pero podemos decir que los medoides que toma como más importantes son las observaciones 638, 51 y 713.

En la tabla podemos ver que a la hora de predecir nuestro árbol de decisión comete cierto error, a continuación analizamos ese error con distintas medidas de precisión.

```{r medidas de precision arbol de decision,echo=TRUE}
# Exactitud/Error
accuracy = sum(prediccion.arbol == setas_test[,1])/nrow(setas_test)
error = 1-accuracy

# Acierto sobre el total de las setas VENENOSAS, sensitivity o recall
sensitivity = sum((prediccion.arbol == setas_test[,1]) & (setas_test[,1] == 1)) / sum(setas_test[,1] == 1)
recall = sensitivity

# Acierto sobre el total de las setas COMESTIBLES
specificity =  sum(prediccion.arbol == setas_test[,1] & setas_test[,1] == 0) / sum(setas_test[,1] == 0)

# Acierto cuando el predicho es VENENOSAS
precision = sum( (prediccion.arbol== setas_test[,1]) & (prediccion.arbol == 1))/ sum(prediccion.arbol == 1)

# Acierto cuando el predicho es COMESTIBLE
npv = sum(prediccion.arbol== setas_test[,1] & prediccion.arbol == 0) / sum(prediccion.arbol == 0)

# F1_score
f1score = 2*precision*recall /(precision+recall)

#Tabla de medidas de precisión
c(accuracy = accuracy, error = error, sensitivity = sensitivity, specificity = specificity, precision = precision, npv = npv, f1=f1score)

```

El error que se comete es superior que en el caso del modelo k-NN con el vecino más próximo, pero sigue siendo un error aceptable para el modelo, por lo que podemos determinar que el árbol de decisión predice casi todas las setas correctamente.


##  Bosques Aleatorios

Random forest es una combinación de árboles predictores tal que cada árbol depende de los valores de un vector aleatorio probado independientemente y con la misma distribución para cada uno de estos. Es una modificación sustancial de bagging que construye una larga colección de árboles no correlacionados y luego los promedia.

```{r bosque aleatorio,echo=TRUE}
setas.rf=randomForest(setas50_train, as.factor(setas50_train.respuesta$Venenosas), ntree=70, importance=FALSE, proximity=TRUE, mtry=4, replace=FALSE,method="class")

#Tabla comparativa
prediccion.rf=predict(setas.rf, setas50_test.data)
table(prediccion.rf,as.factor(setas_test[,1]))
```

La predicción es casi perfecta, pues solo se equivoca clasificando tres setas. Analizamos la precisión de los bosques aleatorios con las medidas de precisión. 
```{r medidas de precision bosques aleatorios,echo=TRUE}
# Exactitud/Error
accuracy = sum(prediccion.rf == setas_test[,1])/nrow(setas_test)
error = 1-accuracy

# Sensibilidad: acierto sobre el total de las setas VENENOSAS
sensitivity = sum((prediccion.rf == setas_test[,1]) & (setas_test[,1] == 1)) / sum(setas_test[,1] == 1)
recall = sensitivity

# Especifidad: acierto sobre el total de las setas COMESTIBLES
specificity =  sum(prediccion.rf == setas_test[,1] & setas_test[,1] == 0) / sum(setas_test[,1] == 0)

# Precisión: acierto cuando el predicho es VENENOSAS
precision = sum( (prediccion.rf== setas_test[,1]) & (prediccion.rf == 1))/ sum(prediccion.rf == 1)

# NPV: acierto cuando el predicho es COMESTIBLE
npv = sum(prediccion.rf== setas_test[,1] & prediccion.rf == 0) / sum(prediccion.rf == 0)

# F1_score
f1score = 2*precision*recall /(precision+recall)

#Tabla de medidas de precisión
c(accuracy = accuracy, error = error, sensitivity = sensitivity, specificity = specificity, precision = precision, npv = npv, f1=f1score)

```

El error que se comete mejora respecto a los dos algoritmo anteriores. Pero esta "perfección" también puede deberse a un sobreajuste de los datos.

##  Support Vector Machines

Las máquinas de vectores soporte  (del inglés support-vector machines, SVM) son un conjunto de algoritmos de aprendizaje supervisado desarrollados por Vladimir Vapnik y su equipo en los laboratorios AT&T.

Estos métodos están propiamente relacionados con problemas de clasificación y regresión. Dado un conjunto de ejemplos de entrenamiento podemos etiquetar las clases y entrenar una SVM para construir un modelo que prediga la clase de una nueva muestra.

Para determinar el valor de gamma y el coste, usamos los datos que hemos reservado para validación y realizamos una estimación con ellos.

```{r svm,echo=TRUE}
# Para estimar el gamma: 
gamma_est=1/apply(setas50_validacion,2,sd)
# Para estimar el coste: 
norma2<-function(x) sqrt(sum(x^2))
cost_est=apply(setas50_validacion,2,norma2)

#Ajustamos el modelo
setas.svm=svm(setas50_train,setas_train[,1],type="C-classification",kernel="radial",gamma=mean(gamma_est),cost=mean(cost_est),scale=F)

#Tabla comparativa
prediccion_svm=predict(setas.svm,setas50_test)
table(prediccion_svm,setas_test[,1])
```

La tabla nos dice que el modelo predice a la perfección los datos. Las medidas de precisión no van a aportar nada que no sepamos con mirar simplemente la tabla.

```{r medidas de precision svm,echo=TRUE}
# Medidas de precisión
accuracy = sum(prediccion_svm == setas_test[,1])/nrow(setas_test[,1])
error = 1-accuracy

# Acierto sobre el total de las setas VENENOSAS, sensitivity o recall
sensitivity = sum((prediccion_svm == setas_test[,1]) & (setas_test[,1] == 1)) / sum(setas_test[,1] == 1)
recall = sensitivity

# Acierto sobre el total de las setas COMESTIBLES
specificity =  sum(prediccion_svm == setas_test[,1] & setas_test[,1] == 0) / sum(setas_test[,1] == 0)

# Acierto cuando el predicho es VENENOSAS
precision = sum((prediccion_svm== setas_test[,1]) & (prediccion_svm == 1))/ sum(prediccion_svm == 1)

# Acierto cuando el predicho es COMESTIBLE
npv = sum(prediccion_svm== setas_test[,1] & prediccion_svm == 0) / sum(prediccion_svm == 0)

# F1_score
f1score = 2*precision*recall /(precision+recall)

#Tabla de medidas de precisión
c(accuracy = accuracy, error = error, sensitivity = sensitivity, specificity = specificity, precision = precision, npv = npv, f1=f1score)
```

Realizamos otro ajuste del modelo pero esta vez ajustando los parámetros a través de la función *tune.svm()*.

```{r svm con ajuste de parametros,echo=TRUE}
#Ajustamos los parámtros
parametros=tune.svm(setas50_validacion, setas_validacion[,1], gamma=seq(5,8.5,by=0.5), cost=seq(10,30,by=10))
attributes(parametros)

# Calculamos el modelo con estos parámetros
setas.svm_parametros=svm(setas50_train,setas_train[,1], type="C-classification", kernel="radial", gamma= parametros$best.parameters[1], cost= parametros$best.parameters[2], scale=F)

# Tabla comparativa
prediccion_svm.parametros=predict(setas.svm_parametros, setas50_test)
table(prediccion_svm.parametros, setas_test[,1])
```

Obtenemos el mismo resultado que en el ajuste anterior, la perfección.

#  Evaluación


#  Visualización y Presentación de Resultados

#  Puesta en producción
OJO!!! al inicio del estudio, necesitamos reservar parte de la bases de datos para esta etapa. Nos referiremos a esa parte como "los datos guardados en un cajón". Normalmente esta etapa se hace "el último día de clase".

#  Actualización del modelo...
Vuelta a empezar.