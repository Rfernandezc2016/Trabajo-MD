---
title: "MINERIA DE DATOS"
author: "Rocío Fernández Cebrián"
date: "29/9/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r graficos}
library(psych)
pairs.panels(datos.setas_train[,c(1,6)],method = "pearson",hist.col = "#00AFBB",density = TRUE,ellipses = TRUE)
pairs(datos.setas_train[,c(1:5)])
```


ANALISIS COMPONENTES PRINCIPALES
```{r PCA}
pca=prcomp(setas_train)
plot(pca)
summary(pca)
nuevos.datos.pca=pca$x[,1:13]

pca.venenosas=which(setas_train[,1]==1)
pca.novenenosas=which(setas_train[,1]==0)

plot(nuevos.datos.pca)
points(nuevos.datos.pca[pca.venenosas,],col="aquamarine",lwd=2)
points(nuevos.datos.pca[pca.novenenosas,],col="purple",lwd=2)

plot(nuevos.datos.pca)
points(nuevos.datos.pca[pca.novenenosas,],col="purple",lwd=2)
points(nuevos.datos.pca[pca.venenosas,],col="aquamarine",lwd=2)


pairs(nuevos.datos.pca[,1:4])
```





ANALISIS CON LA DISTANCIA DICE
```{r PCA}
kmeans(setas,30)
pca=prcomp(distancia_dice)
plot(pca)
summary(pca)
nuevos.datos.pca=pca$x[,1:13]

pca.venenosas=which(setas_train[,1]==1)
pca.novenenosas=which(setas_train[,1]==0)

plot(nuevos.datos.pca)
points(nuevos.datos.pca[pca.venenosas,],col="aquamarine",lwd=2)
points(nuevos.datos.pca[pca.novenenosas,],col="purple",lwd=2)

plot(nuevos.datos.pca)
points(nuevos.datos.pca[pca.novenenosas,],col="purple",lwd=2)
points(nuevos.datos.pca[pca.venenosas,],col="aquamarine",lwd=2)


pairs(nuevos.datos.pca[,1:4])
```



ANALISIS CLUSTER
```{r cluster}
clusters2.datos=kmeans(nuevos.datos.pca,centers=2,nstart=25)
#Números de clusters
SSW <- vector(mode = "numeric", length = 15)
n=dim(nuevos.datos.pca)[1]
#Variabilidad de todos los datos, es decir, todos los datos como un único cluster
SSW[1] <- (n - 1) * sum(apply(setas,2,var)) 

#Variabilidad de cada modelo, desde 2 clusters hasta 15 clusters
for (i in 2:15) SSW[i] <- sum(kmeans(setas,centers=i,nstart=25)$withinss)

#Dibujamos un gráfico con el resultado
plot(1:15, SSW, type="b", xlab="Number of Clusters", ylab="Sum of squares within groups",pch=19, col="steelblue4")


#Cluster con 5 centroides:
clusters8.datos=kmeans(setas,centers=8,nstart=25)
centroides=aggregate(setas,by=list(clusters8.datos$cluster),FUN=mean) 

pairs(setas,col= clusters8.datos$cluster,pch=19)
points(clusters8.datos$centers, col = 1:nk, pch = 19, cex=2)


library(cluster)
clusplot(setas, clusters8.datos$cluster, color=TRUE, shade=TRUE, labels=2,lines=0)
```

CALCULO DE DISTANCIAS
```{r funcion distancia dice}
#Distancia Dice:
#Instalar librerias philentropy,vegan,Rcpp
dist.dice=function(i,j){
    a=sum(i*j)
    d=sum((1-i)*(1-j))
    
    k=length(i)
    
 return ((2*a)/(a+(k-d)))
}
#Matriz de distancia:
distancia_dice=diag(dim(setas)[1])
library(philentropy)
inicio = Sys.time()
distancia_dice=distance(setas,method="dice")
fin = Sys.time()
fin - inicio
#Parece que funciona

distanci_jaccard=diag(dim(setas)[1])
inicio = Sys.time()
distancia_jaccaed=distance(setas,method="jaccard")
fin = Sys.time()
fin - inicio

#i observacion1, j observacion2, k caracteristica
i=1
n=dim(setas)[1]
k=dim(setas)[2]
while(i<n){
  inicio=Sys.time()
  j=i+1
  while(j<=n) {
    #Calculo de similitud
    
    
    distancia_dice[i,j]=((2*a)/(a+(k-d)))
    distancia_dice[j,i]=((2*a)/(a+(k-d)))
    j=j+1
  }
  fin=Sys.time()
  fin-inicio
  i=i+1
}

#Matriz de a:
inicio=Sys.time()
a=diag(500)
i=1
while(i<=500){
  j=i
  while(j<=500){
    a[i,j]=sum(setas[i,2:k]*setas[j,2:k])
    a[j,i]=a[i,j]
    #cat(i,j,a[i,j],"\n")
    j=j+1
  }
  i=i+1
}
fin=Sys.time()
fin-inicio
```


```{r otras distancias}

#Distancia Hamman:
dist.hamman=function(a,b,c,d,matriz,i,j){
  distancia=((a+d)-(b+c))/(a+b+c+d)
  matriz[j,i]=distancia
  matriz[i,j]=distancia
  matriz
}
#Distancia Pearson:
dist.pearson=function(a,b,c,d,matriz,i,j){
  distancia=(a*d)/sqrt((a+b)*(a+c)*(b+d)*(c+d))
  matriz[j,i]=distancia
  matriz[i,j]=distancia
  matriz
}
#Distancia Yule:
dist.yule=function(a,b,c,d,matriz,i,j){
  distancia=((a*d)-(b*c))/((a*d)+(b*c))
  matriz[j,i]=distancia
  matriz[i,j]=distancia
  matriz
}


#Matriz de distancias:
distancia_hamman=diag(dim(setas)[1])
distancia_pearson=diag(dim(setas)[1])
distancia_yule=diag(dim(setas)[1])


    distancia_hamman=dist.hamman(a,b,c,d,distancia_hamman,i,j)
    distancia_pearson=dist.pearson(a,b,c,d,distancia_pearson,i,j)
    distancia_yule=dist.yule(a,b,c,d,distancia_yule,i,j)
```


```{r distancias prueba}
dim_prueba=500

#Matrices de las distintas distancias:
distancia_dice=diag(dim_prueba)
distancia_hamman=diag(dim_prueba)
distancia_pearson=diag(dim_prueba)
distancia_yule=diag(dim_prueba)

inicio=Sys.time()
#i observacion1, j observacion2, k caracteristica
i=1
while(i<=(dim_prueba-1)){
  j=i+1
  while(j<=dim_prueba) {
    a=0
    b=0
    c=0
    d=0
    k=1
    while(k<=dim(setas)[2]) {
      if(i[k]==1 & j[k]==1){
        a=a+1
      }
      if(i[k]==1 & j[k]==0){
        b=b+1
      }
      if(i[k]==0 & j[k]==1){
        c=c+1
      }
      if(i[k]==0 & j[k]==0){
        d=d+1
      }
      k=k+1
    }
    distancia_dice=dist.dice(i,j)
    j=j+1
  }
  i=i+1
}
fin=Sys.time()
fin-inicio
```

